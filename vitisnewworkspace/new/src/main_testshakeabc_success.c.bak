/***************************** Include Files *******************************/
#include "xparameters.h"
#include "xil_printf.h"
#include "xstatus.h"
#include "xil_cache.h"
#include "xil_io.h"
#include "sha3_1003_tIP1.h"

/************************** Constant Definitions ***************************/
#define IP_CORE_BASEADDR        XPAR_SHA3_1003_TIP1_0_S0_AXI_BASEADDR

// 寄存器地址偏移
#define REG_CONTROL_OFFSET      0x00
#define REG_DIN_LOW_OFFSET      0x04
#define REG_DIN_HIGH_OFFSET     0x08
#define REG_CONTROL2_OFFSET     0x0C
#define REG_STATUS_OFFSET       0x10
#define REG_RESULT_START_OFFSET 0x14

// 控制位定义
#define CONTROL_START_BIT       (1 << 3)
#define CONTROL2_LAST_DIN_BIT   (1 << 0)
#define CONTROL2_DIN_VALID_BIT  (1 << 5)
#define CONTROL2_DOUT_READY_BIT (1 << 6)
#define STATUS_RESULT_READY_BIT (1 << 5)

#define RESULT_REG_COUNT 42

/************************** Function Prototypes ****************************/
void init_platform();
void cleanup_platform();
int test_shake_abc(u32 base_addr);

/*****************************************************************************/
/**
 * @brief Main function
 */
int main()
{
    int status;
    init_platform();

    xil_printf("\r\n--- SHA3 IP Core Test for 'abc' input ---\r\n");

    status = test_shake_abc(IP_CORE_BASEADDR);

    if (status == XST_SUCCESS) {
        xil_printf("\r\n[SUCCESS] Test finished successfully.\r\n");
    } else {
        xil_printf("\r\n[FAILURE] An error occurred during the test.\r\n");
    }

    cleanup_platform();
    return status;
}

/*****************************************************************************/
/**
 * @brief    Tests the SHAKE core with "abc" input, using the correct data
 * handling and timing sequence.
 * @param    base_addr is the base address of the IP core.
 * @return   - XST_SUCCESS on success / - XST_FAILURE on failure.
 */
int test_shake_abc(u32 base_addr)
{
    u32 status_reg;
    u32 result_buffer[RESULT_REG_COUNT];
    int i;
    int timeout = 1000000;

    // --- Step 1: Prepare the "abc" input data ---
    // 'a' = 0x61, 'b' = 0x62, 'c' = 0x63
    // We create a 64-bit NUMERIC VALUE where "abc" are the most significant bytes.
    // The C compiler and standard library functions will handle the little-endian
    // conversion automatically when splitting this u64 into two u32s.
    u64 write_data = 0x6162630000000000ULL;

    // Split the 64-bit value into high and low 32-bit parts.
    // This is the robust way to handle endianness.
    u32 high_32 = (u32)(write_data >> 32);
    u32 low_32  = (u32)(write_data & 0xFFFFFFFF);

    xil_printf("\r\n--- Testing SHAKE with input 'abc' ---\r\n");
    xil_printf("Step 1: Preparing data for 'abc' (0x%016llX)\r\n", write_data);
    xil_printf("  - Writing High_32: 0x%08X\r\n", high_32);
    xil_printf("  - Writing Low_32 : 0x%08X\r\n", low_32);

    SHA3_1003_TIP1_mWriteReg(base_addr, REG_DIN_HIGH_OFFSET, high_32);
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_DIN_LOW_OFFSET, low_32);

    // --- Step 2: Set up static control signals ---
    // Since "abc" is 3 bytes, we set the valid byte count to 3.
    u32 control2_val = CONTROL2_LAST_DIN_BIT | (3 << 1) | CONTROL2_DOUT_READY_BIT;
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL2_OFFSET, control2_val);
    xil_printf("Step 2: Setting control signals (byte count = 3), REG_CONTROL2 = 0x%08X\r\n", control2_val);

    // --- Step 3: Start the computation using the short-pulse timing ---
    u32 control_val = 1; // Mode 1: Shake-256
    xil_printf("Step 3: Setting mode to Shake-256 and initiating start sequence...\r\n");

    // 3.1: Ensure a stable state before starting
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL_OFFSET, control_val);

    // 3.2: Send a very short 'start' pulse to trigger the shake_top state machine
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL_OFFSET, control_val | CONTROL_START_BIT);
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL_OFFSET, control_val); // Immediately pull it low
    xil_printf("  - 'Start' pulse sent.\r\n");

    // 3.3: After the start pulse, send the din_valid pulse
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL2_OFFSET, control2_val | CONTROL2_DIN_VALID_BIT);
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL2_OFFSET, control2_val); // Also a pulse
    xil_printf("  - 'din_valid' pulse sent.\r\n");

    // --- Step 4: Wait for the computation to complete ---
    xil_printf("Step 4: Waiting for calculation to finish...\r\n");
    do {
        status_reg = SHA3_1003_TIP1_mReadReg(base_addr, REG_STATUS_OFFSET);
        timeout--;
    } while (((status_reg & STATUS_RESULT_READY_BIT) == 0) && (timeout > 0));

    if (timeout <= 0) {
        xil_printf("  - [ERROR] Timeout! Status Register (REG_STATUS_OFFSET): 0x%08X\r\n", status_reg);
        return XST_FAILURE;
    }
    xil_printf("  - Calculation complete! Status Register: 0x%08X\r\n", status_reg);

    // --- Step 5: Read and print the full 1344-bit result ---
    xil_printf("Step 5: Reading the full hash result...\r\n");
    xil_printf("--- Hash Result ---\r\n");
    for (i = 0; i < RESULT_REG_COUNT; i++) {
        result_buffer[i] = SHA3_1003_TIP1_mReadReg(base_addr, REG_RESULT_START_OFFSET + i * 4);
        xil_printf("    reg[%2d]: 0x%08X\r\n", i, result_buffer[i]);
    }

    return XST_SUCCESS;
}

/*****************************************************************************/
/**
* @brief Initializes the platform
******************************************************************************/
void init_platform()
{
    Xil_ICacheEnable();
    Xil_DCacheEnable();
}

/*****************************************************************************/
/**
* @brief Cleans up the platform
******************************************************************************/
void cleanup_platform()
{
    Xil_DCacheDisable();
    Xil_ICacheDisable();
}

/**
 * @file shake_sha2_test.c
 * @brief 测试SHA2-256, SHA2-512 和 SHAKE256 模式 - 处理16字节输入
 */

#include "xparameters.h"
#include "stdio.h"

#include "shake_sha2_ip.h"
#include "xil_io.h"

// 寄存器偏移定义
#define REG_CONTROL      SHAKE_SHA2_IP_S00_AXI_SLV_REG0_OFFSET   // 控制寄存器: algo_mode[3:0], start(4), hold(5)
#define REG_INPUT_LOW    SHAKE_SHA2_IP_S00_AXI_SLV_REG1_OFFSET   // SHAKE 输入数据低32位
#define REG_INPUT_HIGH   SHAKE_SHA2_IP_S00_AXI_SLV_REG2_OFFSET   // SHAKE 输入数据高32位
#define REG_CONTROL2     SHAKE_SHA2_IP_S00_AXI_SLV_REG3_OFFSET   // SHAKE 控制: last_din(0), last_din_byte[3:0](4:1), din_valid(5), dout_ready(6)
#define REG_SHA2_TDATA   SHAKE_SHA2_IP_S00_AXI_SLV_REG4_OFFSET   // SHA2 tdata (低8位)
#define REG_SHA2_TID     SHAKE_SHA2_IP_S00_AXI_SLV_REG5_OFFSET   // SHA2 tid
#define REG_SHA2_CONTROL SHAKE_SHA2_IP_S00_AXI_SLV_REG6_OFFSET   // SHA2 tvalid(0), tlast(1)
#define REG_STATUS       SHAKE_SHA2_IP_S00_AXI_SLV_REG7_OFFSET   // 状态寄存器: state[2:0], dout_valid(3), busy(4), result_ready(5), sha2_tready(6), sha2_ovalid(7)
#define REG_RESULT_BASE  SHAKE_SHA2_IP_S00_AXI_SLV_REG11_OFFSET  // 结果寄存器起始地址

// 状态位定义
#define STATUS_TREADY       0x40   // SHA2 tready (bit 6)
#define STATUS_RESULT_READY 0x20   // 结果准备就绪标志 (bit 5)

// 模式定义
#define MODE_SHA2_256       0      // SHA2-256 模式
#define MODE_SHA2_512       1      // SHA2-512 模式
#define MODE_SHAKE_256      9      // SHAKE-256 模式 (1001 binary)

// 输入数据: 16字节
u8 input_data[16] = {0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10};

/**
 * 等待结果就绪
 * @param base_address AXI基地址
 */
void wait_for_result_ready(u32 base_address) {
    u32 status;
    do {
        status = SHAKE_SHA2_IP_mReadReg(base_address, REG_STATUS);
    } while ((status & STATUS_RESULT_READY) == 0);
}

/**
 * 读取并打印结果
 * @param base_address AXI基地址
 * @param result 结果存储数组（42个u32）
 */
void read_and_print_result(u32 base_address, u32 *result) {
    xil_printf("DEBUG: Reading hash output...\r\n");
    for (int i = 0; i < 42; i++) {
        result[i] = SHAKE_SHA2_IP_mReadReg(base_address, REG_RESULT_BASE + i * 4);
    }

    xil_printf("DEBUG: Complete 1344-bit result:\r\n");
    for (int i = 0; i < 42; i++) {
        if (i % 8 == 0) xil_printf("\r\n[%02d-%02d]: ", i, (i+7 < 42) ? i+7 : 41);
        xil_printf("0x%08X ", result[i]);
    }
    xil_printf("\r\n");
}

/**
 * SHA2 测试函数 - 处理16字节输入，字节逐个发送
 * @param base_address AXI基地址
 * @param mode SHA2模式 (0: SHA2-256, 1: SHA2-512)
 * @param result 结果存储数组（至少42个u32）
 * @return 0 如果成功，-1 如果失败
 */
int simple_sha2_test(u32 base_address, u32 mode, u32 *result) {
    xil_printf("DEBUG: Starting SHA2 calculation for 16-byte input\r\n");
    xil_printf("DEBUG: BaseAddr=0x%08X, Mode=%d (SHA2-%s)\r\n", base_address, mode, mode ? "512" : "256");

    // 1. 设置模式（SHA2 无需start）
    u32 control_value = (mode & 0xF);
    xil_printf("DEBUG: Set mode, Control reg = 0x%08X\r\n", control_value);
    SHAKE_SHA2_IP_mWriteReg(base_address, REG_CONTROL, control_value);

    // 2. 发送16个字节数据
    for (int i = 0; i < 16; i++) {
        // 等待 tready == 1
        u32 status;
        do {
            status = SHAKE_SHA2_IP_mReadReg(base_address, REG_STATUS);
        } while ((status & STATUS_TREADY) == 0);

        // 写入 tdata (低8位)
        u32 tdata_value = input_data[i];
        xil_printf("DEBUG: Write byte %d: 0x%02X\r\n", i, tdata_value);
        SHAKE_SHA2_IP_mWriteReg(base_address, REG_SHA2_TDATA, tdata_value);

        // 写入 tid (设为0)
        SHAKE_SHA2_IP_mWriteReg(base_address, REG_SHA2_TID, 0);

        // 设置 tvalid=1, tlast=1 if last
        u32 sha2_control = 1;  // tvalid=1
        if (i == 15) sha2_control |= (1 << 1);  // tlast=1
        xil_printf("DEBUG: Set tvalid (and tlast if last), SHA2 Control reg = 0x%08X\r\n", sha2_control);
        SHAKE_SHA2_IP_mWriteReg(base_address, REG_SHA2_CONTROL, sha2_control);

        // 立即清零 tvalid，形成脉冲
        sha2_control &= ~1;
        SHAKE_SHA2_IP_mWriteReg(base_address, REG_SHA2_CONTROL, sha2_control);
    }

    // 3. 等待结果就绪
    wait_for_result_ready(base_address);

    // 4. 读取结果
    read_and_print_result(base_address, result);

    return 0;
}

/**
 * SHAKE 测试函数 - 处理16字节输入，分两次8字节发送
 * @param base_address AXI基地址
 * @param result 结果存储数组（至少42个u32）
 * @return 0 如果成功，-1 如果失败
 */
int simple_shake256_test(u32 base_address, u32 *result) {
    xil_printf("DEBUG: Starting SHAKE256 calculation for 16-byte input\r\n");
    xil_printf("DEBUG: BaseAddr=0x%08X, Mode=%d\r\n", base_address, MODE_SHAKE_256);

    // 1. 设置模式
    u32 control_value = (MODE_SHAKE_256 & 0xF);
    xil_printf("DEBUG: Set mode, Control reg = 0x%08X\r\n", control_value);
    SHAKE_SHA2_IP_mWriteReg(base_address, REG_CONTROL, control_value);

    // 2. 启动脉冲
    control_value |= (1 << 4);
    xil_printf("DEBUG: Send start pulse, Control reg = 0x%08X\r\n", control_value);
    SHAKE_SHA2_IP_mWriteReg(base_address, REG_CONTROL, control_value);
    control_value &= ~(1 << 4);
    xil_printf("DEBUG: Clear start bit, Control reg = 0x%08X\r\n", control_value);
    SHAKE_SHA2_IP_mWriteReg(base_address, REG_CONTROL, control_value);

    // 3. 发送第一个8字节数据
    u64 first_data = *(u64*)(input_data);  // 前8字节
    u32 first_low = (u32)(first_data & 0xFFFFFFFF);
    u32 first_high = (u32)(first_data >> 32);
    xil_printf("DEBUG: Write first data - Low32=0x%08X, High32=0x%08X\r\n", first_low, first_high);
    SHAKE_SHA2_IP_mWriteReg(base_address, REG_INPUT_LOW, first_low);
    SHAKE_SHA2_IP_mWriteReg(base_address, REG_INPUT_HIGH, first_high);

    // din_valid=1, last_din=0, last_din_byte=8
    u32 control2_value = (1 << 5) | (8 << 1);
    xil_printf("DEBUG: Send first data valid, Control2 reg = 0x%08X\r\n", control2_value);
    SHAKE_SHA2_IP_mWriteReg(base_address, REG_CONTROL2, control2_value);

    // 立即清除 din_valid，形成脉冲
    control2_value &= ~(1 << 5);
    SHAKE_SHA2_IP_mWriteReg(base_address, REG_CONTROL2, control2_value);

    // 4. 发送第二个8字节数据 (last_din=1)
    u64 second_data = *(u64*)(input_data + 8);  // 后8字节
    u32 second_low = (u32)(second_data & 0xFFFFFFFF);
    u32 second_high = (u32)(second_data >> 32);
    xil_printf("DEBUG: Write second data - Low32=0x%08X, High32=0x%08X\r\n", second_low, second_high);
    SHAKE_SHA2_IP_mWriteReg(base_address, REG_INPUT_LOW, second_low);
    SHAKE_SHA2_IP_mWriteReg(base_address, REG_INPUT_HIGH, second_high);

    // din_valid=1, last_din=1, last_din_byte=8
    control2_value = (1 << 5) | (8 << 1) | (1 << 0);
    xil_printf("DEBUG: Send last data valid, Control2 reg = 0x%08X\r\n", control2_value);
    SHAKE_SHA2_IP_mWriteReg(base_address, REG_CONTROL2, control2_value);

    // 立即清除 din_valid，形成脉冲
    control2_value &= ~(1 << 5);
    SHAKE_SHA2_IP_mWriteReg(base_address, REG_CONTROL2, control2_value);

    // 5. 设置 dout_ready=1
    control2_value = (1 << 6);
    xil_printf("DEBUG: Input complete, set dout_ready, Control2 reg = 0x%08X\r\n", control2_value);
    SHAKE_SHA2_IP_mWriteReg(base_address, REG_CONTROL2, control2_value);

    // 6. 等待结果就绪
    wait_for_result_ready(base_address);

    // 7. 读取结果
    read_and_print_result(base_address, result);

    return 0;
}

/**
 * 主函数
 */
int main() {
    u32 base_addr = XPAR_SHAKE_SHA2_IP_V1_0_S_0_BASEADDR;
    u32 result_buffer[42];

    xil_printf("\n========================================\n\r");
    xil_printf("       SHA2/SHAKE 16-Byte Input Test\n\r");
    xil_printf("========================================\n\r");
    xil_printf("Base Address: 0x%08X\n\r", base_addr);
    xil_printf("Input: 0123456789abcdeffedcba9876543210\n\r");

    // 测试 SHA2-256
    xil_printf("\n--- SHA2-256 Test ---\n\r");
    int status256 = simple_sha2_test(base_addr, MODE_SHA2_256, result_buffer);
    xil_printf("SHA2-256 Test %s\n\r", (status256 == 0) ? "+ Passed" : "X Failed");

    // 测试 SHA2-512
    xil_printf("\n--- SHA2-512 Test ---\n\r");
    int status512 = simple_sha2_test(base_addr, MODE_SHA2_512, result_buffer);
    xil_printf("SHA2-512 Test %s\n\r", (status512 == 0) ? "+ Passed" : "X Failed");

    // 测试 SHAKE256
    xil_printf("\n--- SHAKE256 Test ---\n\r");
    int status_shake = simple_shake256_test(base_addr, result_buffer);
    xil_printf("SHAKE256 Test %s\n\r", (status_shake == 0) ? "+ Passed" : "X Failed");

    return 0;
}

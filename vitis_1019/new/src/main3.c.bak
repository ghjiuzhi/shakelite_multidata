/***************************** Include Files *******************************/
#include "xparameters.h"
#include "xil_printf.h"
#include "xstatus.h"
#include "xil_cache.h"
#include "xil_io.h"
#include "sha3_1003_tIP1.h"

/************************** Constant Definitions ***************************/
#define IP_CORE_BASEADDR        XPAR_SHA3_1003_TIP1_0_S0_AXI_BASEADDR
#define REG_CONTROL_OFFSET      0x00
#define REG_DIN_LOW_OFFSET      0x04
#define REG_DIN_HIGH_OFFSET     0x08
#define REG_CONTROL2_OFFSET     0x0C
#define REG_STATUS_OFFSET       0x10
#define REG_RESULT_START_OFFSET 0x14
#define CONTROL_START_BIT       (1 << 3)
#define CONTROL2_LAST_DIN_BIT   (1 << 0)
#define CONTROL2_DIN_VALID_BIT  (1 << 5)
#define CONTROL2_DOUT_READY_BIT (1 << 6)
#define STATUS_RESULT_READY_BIT (1 << 5)
#define RESULT_REG_COUNT 42

/************************** Function Prototypes ****************************/
void init_platform();
void cleanup_platform();
int run_test(u32 base_addr, const char* test_name, u32 high, u32 low, int use_validation_timing);
void print_separator();
void print_conclusion(int test1a_res, int test1b_res, int test2a_res, int test2b_res);

/*****************************************************************************/
int main()
{
    init_platform();
    xil_printf("\r\n\n\n--- SHA3 IP Core: Final Diagnostic Program ---\r\n");
    xil_printf("--- Objective: Validate if 'start_i' signal incorrectly resets the core ---\r\n");

    // =========================================================================
    // Round 1: Using "Standard Timing"
    // Hypothesis: Results will be identical, proving inputs are ignored.
    // =========================================================================
    print_separator();
    xil_printf("Round 1 Test: Using 'Standard Timing' (the previously failing method)\r\n");
    xil_printf("Expectation: The hash results for the next two tests should be IDENTICAL.\r\n");
    print_separator();

    int test1a_res = run_test(IP_CORE_BASEADDR, "Test 1-A", 0xAAAAAAAA, 0xBBBBBBBB, 0);
    int test1b_res = run_test(IP_CORE_BASEADDR, "Test 1-B", 0xCCCCCCCC, 0xDDDDDDDD, 0);

    // =========================================================================
    // Round 2: Using "Validation Timing"
    // Hypothesis: Results will be different, proving inputs are processed correctly.
    // =========================================================================
    print_separator();
    xil_printf("Round 2 Test: Using 'Validation Timing' (short start pulse)\r\n");
    xil_printf("Expectation: The hash results for the next two tests should be DIFFERENT.\r\n");
    print_separator();

    int test2a_res = run_test(IP_CORE_BASEADDR, "Test 2-A", 0xAAAAAAAA, 0xBBBBBBBB, 1);
    int test2b_res = run_test(IP_CORE_BASEADDR, "Test 2-B", 0xCCCCCCCC, 0xDDDDDDDD, 1);

    // =========================================================================
    // Final Conclusion
    // =========================================================================
    print_conclusion(test1a_res, test1b_res, test2a_res, test2b_res);

    cleanup_platform();
    return 0;
}


/*****************************************************************************/
/**
* @brief    Runs a single SHA computation, with a choice of timing methods.
******************************************************************************/
int run_test(u32 base_addr, const char* test_name, u32 high, u32 low, int use_validation_timing)
{
    u32 status_reg;
    u32 result_buffer[RESULT_REG_COUNT] = {0};
    int i;
    int timeout = 1000000;
    u32 control_val = 1; // Mode 1: Shake-256
    u32 control2_val = CONTROL2_LAST_DIN_BIT | (8 << 1) | CONTROL2_DOUT_READY_BIT;

    xil_printf("\r\n--- %s ---\r\n", test_name);
    xil_printf("Input Data -> High: 0x%08X, Low: 0x%08X\r\n", high, low);

    // Write data and static controls
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_DIN_HIGH_OFFSET, high);
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_DIN_LOW_OFFSET, low);
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL2_OFFSET, control2_val);

    if (use_validation_timing) {
        // --- "Validation Timing" (Short Start Pulse) ---
        xil_printf("Execution Method: Validation Timing (Short Start Pulse)\r\n");
        SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL_OFFSET, control_val); // Prepare
        // Send a very short start pulse
        SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL_OFFSET, control_val | CONTROL_START_BIT);
        SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL_OFFSET, control_val);
        // Then, after start is done, send the din_valid pulse
        SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL2_OFFSET, control2_val | CONTROL2_DIN_VALID_BIT);
        SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL2_OFFSET, control2_val);

    } else {
        // --- "Standard Timing" (Previously Failing Method) ---
        xil_printf("Execution Method: Standard Timing (Long Start Signal)\r\n");
        SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL_OFFSET, control_val); // Prepare
        // Raise start and din_valid
        SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL_OFFSET, control_val | CONTROL_START_BIT);
        SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL2_OFFSET, control2_val | CONTROL2_DIN_VALID_BIT);
        // Lower them
        SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL_OFFSET, control_val);
        SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL2_OFFSET, control2_val);
    }

    // Wait for calculation to complete
    do {
        status_reg = SHA3_1003_TIP1_mReadReg(base_addr, REG_STATUS_OFFSET);
        timeout--;
    } while (((status_reg & STATUS_RESULT_READY_BIT) == 0) && (timeout > 0));

    if (timeout <= 0) {
        xil_printf("  [ERROR] Timeout waiting for completion! Status Reg: 0x%08X\r\n", status_reg);
        return -1; // Return error code
    }

    // Read and print the first non-zero result register for a quick comparison
    for (i = 0; i < RESULT_REG_COUNT; i++) {
        result_buffer[i] = SHA3_1003_TIP1_mReadReg(base_addr, REG_RESULT_START_OFFSET + i * 4);
        if(result_buffer[i] != 0) {
            xil_printf("Hash Result (reg[%d]): 0x%08X\r\n", i, result_buffer[i]);
            return result_buffer[i]; // Return the first non-zero value for comparison
        }
    }
    xil_printf("Hash Result: All zeroes\r\n");
    return 0; // Return 0 if all results are zero
}

/*****************************************************************************/
void print_separator()
{
    xil_printf("=====================================================================\r\n");
}

/*****************************************************************************/
void print_conclusion(int test1a_res, int test1b_res, int test2a_res, int test2b_res)
{
    print_separator();
    xil_printf("Final Diagnostic Conclusion:\r\n");
    print_separator();

    // Check Round 1
    if (test1a_res == test1b_res) {
        xil_printf("[SUCCESS] Validation Pass: With 'Standard Timing', different inputs (0xAAAA... vs 0xCCCC...) produced the IDENTICAL result.\r\n");
        xil_printf("    >> This proves the hardware IGNORED the input data with this timing.\r\n");
    } else {
        xil_printf("[FAIL] Validation Anomaly: With 'Standard Timing', different inputs produced DIFFERENT results. This contradicts previous observations.\r\n");
    }

    // Check Round 2
    if (test2a_res != test2b_res) {
        xil_printf("[SUCCESS] Validation Pass: With 'Validation Timing', different inputs (0xAAAA... vs 0xCCCC...) produced DIFFERENT results.\r\n");
        xil_printf("    >> This proves the hardware CORRECTLY processed the input data with this timing.\r\n");
    } else {
        xil_printf("[FAIL] Validation Anomaly: With 'Validation Timing', different inputs produced the IDENTICAL result. This implies the problem is more complex.\r\n");
    }

    print_separator();

    // Final Verdict
    if ((test1a_res == test1b_res) && (test2a_res != test2b_res) && (test1a_res != -1) && (test2a_res != -1)) {
        xil_printf("【VERDICT】: The hypothesis is CONFIRMED!\r\n");
        xil_printf("The root cause is a design flaw in your Verilog code. The 'start_i' signal is incorrectly connected to the reset port of the 'keccak_top' core.\r\n");
        xil_printf("ACTION: Modify 'shake_top.v', connect the '.Reset' port of 'keccak_top' ONLY to '~rst_ni', and then regenerate the hardware.\r\n");
    } else {
        xil_printf("【VERDICT】: The experiment did not fully confirm the hypothesis. The results are inconclusive or point to a different issue.\r\n");
    }
}

/*****************************************************************************/
void init_platform() { Xil_ICacheEnable(); Xil_DCacheEnable(); }
void cleanup_platform() { Xil_DCacheDisable(); Xil_ICacheDisable(); }

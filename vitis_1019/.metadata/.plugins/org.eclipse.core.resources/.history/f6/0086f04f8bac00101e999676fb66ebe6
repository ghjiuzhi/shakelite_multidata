#include "fpga_sha_driver.h"
#include "xil_io.h"
#include <string.h>

// 寄存器x宏
#define SHA_HW_WriteReg(BaseAddress, RegOffset, Data) \
    Xil_Out32((BaseAddress) + (RegOffset), (u32)(Data))

#define SHA_HW_ReadReg(BaseAddress, RegOffset) \
    Xil_In32((BaseAddress) + (RegOffset))

/* * o助函 1：SHAKE 出理 (碜阅愕呐f)
 * 你的f `reorder_and_swap_bytes` 是募拇嫫髂┪蚕蚯白x取K交Q字。
 * 我保留@o SHAKE。
 */
static void reorder_and_swap_bytes_shake(unsigned char* dest, const u32* src_regs, size_t num_bytes_to_reorder) {
    size_t num_regs_to_process = (num_bytes_to_reorder + 3) / 4;
    if (num_regs_to_process > RESULT_REG_COUNT) {
        num_regs_to_process = RESULT_REG_COUNT;
    }

    for (size_t i = 0; i < num_regs_to_process; i++) {
        // 尼嵯蚯白x取寄存器 (src_regs[41], src_regs[40], ...)
        u32 current_reg_val = src_regs[RESULT_REG_COUNT - 1 - i];

        if (i * 4 + 0 < num_bytes_to_reorder)
            dest[i * 4 + 0] = (current_reg_val >> 24) & 0xFF;
        if (i * 4 + 1 < num_bytes_to_reorder)
            dest[i * 4 + 1] = (current_reg_val >> 16) & 0xFF;
        if (i * 4 + 2 < num_bytes_to_reorder)
            dest[i * 4 + 2] = (current_reg_val >> 8)  & 0xFF;
        if (i * 4 + 3 < num_bytes_to_reorder)
            dest[i * 4 + 3] = (current_reg_val >> 0)  & 0xFF;
    }
}

/* * o助函 2：SHA-2 出理 (新)
 * 根 shake_sha2_top.v，SHA-2 Y果位於 dout 的前端 (低地址)。
 * 我募拇嫫鏖_^ (REG11) 向後x取K交Q字。
 */
static void reorder_and_swap_bytes_sha2(unsigned char* dest, const u32* src_regs, size_t num_bytes_to_copy) {
    size_t num_regs_to_process = (num_bytes_to_copy + 3) / 4;

    for (size_t i = 0; i < num_regs_to_process; i++) {
        // 那跋蜥嶙x取寄存器 (src_regs[0], src_regs[1], ...)
        u32 current_reg_val = src_regs[i];

        if (i * 4 + 0 < num_bytes_to_copy)
            dest[i * 4 + 0] = (current_reg_val >> 24) & 0xFF;
        if (i * 4 + 1 < num_bytes_to_copy)
            dest[i * 4 + 1] = (current_reg_val >> 16) & 0xFF;
        if (i * 4 + 2 < num_bytes_to_copy)
            dest[i * 4 + 2] = (current_reg_val >> 8)  & 0xFF;
        if (i * 4 + 3 < num_bytes_to_copy)
            dest[i * 4 + 3] = (current_reg_val >> 0)  & 0xFF;
    }
}


/* --- 炔 SHA-2 舆 --- */
// 栏褡裱 shake_sha2_test.c 的
static void sha2_hw_internal(uint8_t *out, size_t outlen, const uint8_t *in, size_t inlen, HwHashMode mode)
{
    u32 base_addr = IP_CORE_BASEADDR;
    u32 status;
    int timeout;

    // 1. O置模式 (SHA2-256 或 SHA2-512)
    SHA_HW_WriteReg(base_addr, REG_CONTROL_OFFSET, (u32)mode);

    // 2. 循hl送 (逐字)，使用 tvalid }_
    for (size_t i = 0; i < inlen; i++) {
        // 等待 tready == 1
        timeout = 1000000;
        do {
            status = SHA_HW_ReadReg(base_addr, REG_STATUS_OFFSET);
            if (timeout-- <= 0) { /* 理超r */ return; }
        } while ((status & STATUS_SHA2_TREADY_BIT) == 0);

        // 入 tdata
        SHA_HW_WriteReg(base_addr, REG_SHA2_TDATA_OFFSET, (u32)in[i]);
        SHA_HW_WriteReg(base_addr, REG_SHA2_TID_OFFSET, 0);

        // O置 tvalid=1, tlast=1 (如果是最後)
        u32 sha2_control = SHA2_CONTROL_TVALID_BIT;
        if (i == (inlen - 1)) {
            sha2_control |= SHA2_CONTROL_TLAST_BIT;
        }
        SHA_HW_WriteReg(base_addr, REG_SHA2_CONTROL_OFFSET, sha2_control);

        // 立即清零 tvalid (遵循 shake_sha2_test.c 的}_)
        sha2_control &= ~SHA2_CONTROL_TVALID_BIT;
        SHA_HW_WriteReg(base_addr, REG_SHA2_CONTROL_OFFSET, sha2_control);
    }

    // 3. 等待Y果 (遵循 shake_sha2_test.c 的)
    timeout = 1000000;
    while (((SHA_HW_ReadReg(base_addr, REG_STATUS_OFFSET) & STATUS_RESULT_READY_BIT) == 0) && (timeout > 0)) {
        timeout--;
    }
    if (timeout <= 0) { /* 理超r */ return; }

    // 4. x取Y果
    u32 result_regs[SHA512_REG_COUNT]; // 分配足 SHA512 的空g
    size_t regs_to_read = (mode == HW_MODE_SHA2_256) ? SHA256_REG_COUNT : SHA512_REG_COUNT;

    for (size_t i = 0; i < regs_to_read; i++) {
        result_regs[i] = SHA_HW_ReadReg(base_addr, REG_RESULT_START_OFFSET + i * 4);
    }

    // 5. }uK交Q字序到出 (SHA-2 Y果在寄存器前端)
    reorder_and_swap_bytes_sha2(out, result_regs, outlen);
}


/* --- 炔 SHAKE256 舆 --- */
// @是你的舆，但更新了所有宏定x以匹配新 IP
static void shake256_hw_internal(uint8_t *out, size_t outlen, const uint8_t *in, const size_t inlen)
{
    u32 base_addr = IP_CORE_BASEADDR;
    size_t remaining_len = inlen;
    const uint8_t *data_ptr = in;
    int timeout;

    /* --- 步E 1 & 2: O置模式Kl送用}_ (使用更新後的定x) --- */
    u32 control_val = (HW_MODE_SHAKE_256 & 0xF); // 模式 9
    SHA_HW_WriteReg(base_addr, REG_CONTROL_OFFSET, control_val);
    SHA_HW_WriteReg(base_addr, REG_CONTROL_OFFSET, control_val | CONTROL_SHAKE_START_BIT); // bit 4
    SHA_HW_WriteReg(base_addr, REG_CONTROL_OFFSET, control_val);

    /* --- 步E 3: 循hl送K --- */
    while (remaining_len > 0) {
        u64 chunk = 0;
        size_t bytes_to_process = (remaining_len >= 8) ? 8 : remaining_len;

        for (size_t i = 0; i < bytes_to_process; i++) {
            chunk |= (u64)data_ptr[i] << (56 - (i * 8));
        }

        SHA_HW_WriteReg(base_addr, REG_DIN_HIGH_OFFSET, (u32)(chunk >> 32));
        SHA_HW_WriteReg(base_addr, REG_DIN_LOW_OFFSET,  (u32)(chunk & 0xFFFFFFFF));

        u32 control2_val = ((u32)bytes_to_process << 1);

        if (remaining_len <= 8) {
            control2_val |= CONTROL2_LAST_DIN_BIT;
            SHA_HW_WriteReg(base_addr, REG_CONTROL2_OFFSET, control2_val | CONTROL2_DIN_VALID_BIT);
            // 你的釉谧钺嵋K後立即清除了 valid KO置了 dout_ready
            SHA_HW_WriteReg(base_addr, REG_CONTROL2_OFFSET, CONTROL2_DOUT_READY_BIT);
        } else {
            SHA_HW_WriteReg(base_addr, REG_CONTROL2_OFFSET, control2_val | CONTROL2_DIN_VALID_BIT);
            SHA_HW_WriteReg(base_addr, REG_CONTROL2_OFFSET, control2_val); // 清除 valid
        }

        data_ptr += bytes_to_process;
        remaining_len -= bytes_to_process;
    }

    if (inlen == 0) {
        SHA_HW_WriteReg(base_addr, REG_DIN_HIGH_OFFSET, 0);
        SHA_HW_WriteReg(base_addr, REG_DIN_LOW_OFFSET,  0);
        u32 control2_final = CONTROL2_LAST_DIN_BIT | (0 << 1);
        SHA_HW_WriteReg(base_addr, REG_CONTROL2_OFFSET, control2_final | CONTROL2_DIN_VALID_BIT);
        SHA_HW_WriteReg(base_addr, REG_CONTROL2_OFFSET, CONTROL2_DOUT_READY_BIT);
    }

    /* --- 步E 4: 等待硬件算完成 --- */
    timeout = 1000000;
    while (((SHA_HW_ReadReg(base_addr, REG_STATUS_OFFSET) & STATUS_RESULT_READY_BIT) == 0) && (timeout > 0)) {
        timeout--;
    }
    if (timeout <= 0) {
        xil_printf("[ERROR] Timeout waiting for SHAKE hardware result!\r\n");
        memset(out, 0xEE, outlen);
        return;
    }

    /* --- 步E 5: x取K重排Y果 --- */
    u32 result_regs[RESULT_REG_COUNT];
    for (int i = 0; i < RESULT_REG_COUNT; i++) {
        result_regs[i] = SHA_HW_ReadReg(base_addr, REG_RESULT_START_OFFSET + i * 4);
    }

    // 你的 SHAKE 邮褂么撕
    reorder_and_swap_bytes_shake(out, result_regs, outlen);
}


/* --- 公共 API 函 --- */

void shake256_hw(uint8_t *out, size_t outlen, const uint8_t *in, const size_t inlen)
{
    shake256_hw_internal(out, outlen, in, inlen);
}

void sha256_hw(uint8_t *out, const uint8_t *in, size_t inlen)
{
    // SHA256 出固定 32 字
    sha2_hw_internal(out, 32, in, inlen, HW_MODE_SHA2_256);
}

void sha512_hw(uint8_t *out, const uint8_t *in, size_t inlen)
{
    // SHA512 出固定 64 字
    sha2_hw_internal(out, 64, in, inlen, HW_MODE_SHA512);
}

#include "xil_printf.h"
#include "xil_types.h"
#include "xstatus.h"
#include "xil_cache.h"
#include "xil_io.h"
#include <string.h>

/* Include the low-level driver definitions */
#include "sha3_1003_tIP1.h"

/************************** Constant Definitions ***************************/
#define IP_CORE_BASEADDR        XPAR_SHA3_1003_TIP1_0_S0_AXI_BASEADDR

/* Register address offsets */
#define REG_CONTROL_OFFSET      0x00
#define REG_DIN_LOW_OFFSET      0x04
#define REG_DIN_HIGH_OFFSET     0x08
#define REG_CONTROL2_OFFSET     0x0C
#define REG_STATUS_OFFSET       0x10
#define REG_RESULT_START_OFFSET 0x14

/* Control bit definitions */
#define CONTROL_START_BIT       (1 << 3)
#define CONTROL2_LAST_DIN_BIT   (1 << 0)
#define CONTROL2_DIN_VALID_BIT  (1 << 5)
#define CONTROL2_DOUT_READY_BIT (1 << 6)
#define STATUS_RESULT_READY_BIT (1 << 5)

#define RESULT_REG_COUNT 42
#define MODE_SHAKE_256   1 // Mode is SHAKE-256

/************************** Function Prototypes ****************************/
void init_platform();
void cleanup_platform();
int final_hardware_test(u32 base_addr);
void print_hex_inline(const char *label, const unsigned char *data, size_t len);
void reorder_and_swap_bytes(unsigned char* dest, const u32* src, size_t num_bytes_to_reorder);

/*****************************************************************************/
int main()
{
    init_platform();
    xil_printf("\r\n--- Final Hardware SHAKE256 8-Byte Input Test ---\r\n");
    xil_printf("--- Testing input 0xEFCDAB9078563412 ---\r\n\n");

    int status = final_hardware_test(IP_CORE_BASEADDR);

    cleanup_platform();
    return status;
}

/*****************************************************************************/
/**
 * @brief Tests the SHAKE256 hardware core using the 8-byte input
 * 0xEFCDAB9078563412.
 * @param base_addr The base address of the IP core.
 * @return XST_SUCCESS on match, XST_FAILURE on mismatch.
 */
int final_hardware_test(u32 base_addr)
{
    u32 result_regs[RESULT_REG_COUNT];
    unsigned char reordered_hardware_output[32];

    /* This is the golden output for SHAKE256(0xEFCDAB9078563412) */
    const unsigned char golden_output[32] = {
        0x1A, 0x45, 0x17, 0x14, 0x8A, 0x14, 0x01, 0x3E, 0x90, 0x83, 0x32, 0xC9,
        0x54, 0x28, 0x58, 0x88, 0xA2, 0xA7, 0x27, 0x78, 0x8C, 0x03, 0x73, 0x0B,
        0x56, 0x1C, 0x23, 0xB3, 0x78, 0xE0, 0x3F, 0x90
    };

    xil_printf("DEBUG: Starting SHAKE256 calculation for 8-byte input\r\n");

    /* --- Step 1: Set mode (SHAKE-256) without starting --- */
    u32 control_val = (MODE_SHAKE_256 & 0x7);
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL_OFFSET, control_val);
    xil_printf("DEBUG: Mode set. Control reg = 0x%08X\r\n", control_val);

    /* --- Step 2: Send a start pulse --- */
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL_OFFSET, control_val | CONTROL_START_BIT);
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL_OFFSET, control_val); // Clear start bit
    xil_printf("DEBUG: Start pulse sent.\r\n");

    /* --- Step 3: Write the single input data block --- */
    u64 write_data = 0xEFCDAB9078563412ULL;
    u32 high_32 = (u32)(write_data >> 32);
    u32 low_32  = (u32)(write_data & 0xFFFFFFFF);

    SHA3_1003_TIP1_mWriteReg(base_addr, REG_DIN_HIGH_OFFSET, high_32);
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_DIN_LOW_OFFSET, low_32);
    xil_printf("DEBUG: Wrote data - Low32=0x%08X, High32=0x%08X\r\n", low_32, high_32);

    /* --- Step 4: Send the data with a din_valid pulse (this is the last block) --- */
    // Set din_valid=1, last_din=1, last_din_byte=8
    u32 control2_val = CONTROL2_DIN_VALID_BIT | (8 << 1) | CONTROL2_LAST_DIN_BIT;
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL2_OFFSET, control2_val);
    xil_printf("DEBUG: Send last data valid (8 bytes). Control2 reg = 0x%08X\r\n", control2_val);

    /* --- Step 5: Clear din_valid and set dout_ready to signal input is complete --- */
    control2_val = CONTROL2_DOUT_READY_BIT; // dout_ready=1, clear all other bits
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL2_OFFSET, control2_val);
    xil_printf("DEBUG: Input complete, set dout_ready. Control2 reg = 0x%08X\r\n", control2_val);

    /* --- Step 6: Read all raw result registers --- */
    for (int i = 0; i < RESULT_REG_COUNT; i++) {
        result_regs[i] = SHA3_1003_TIP1_mReadReg(base_addr, REG_RESULT_START_OFFSET + i * 4);
    }

    /* --- Step 7: Reorder data for comparison --- */
    reorder_and_swap_bytes(reordered_hardware_output, result_regs, 32);

    /* --- Step 8: Final Verdict --- */
    xil_printf("\r\n--- Final Verdict ---\r\n");
    print_hex_inline("  Expected Output (Golden Vector) ", golden_output, 32);
    print_hex_inline("  Actual Reordered Output (Hardware)", reordered_hardware_output, 32);

    if (memcmp(reordered_hardware_output, golden_output, 32) == 0) {
        xil_printf("\r\n[HARDWARE IP PASSED!] The hardware output matches the golden vector.\r\n");
        return XST_SUCCESS;
    } else {
        xil_printf("\r\n[HARDWARE IP FAILED!] The hardware result does not match.\r\n");
        return XST_FAILURE;
    }
}

/**
 * @brief Reorders registers from back-to-front and handles endianness.
 */
void reorder_and_swap_bytes(unsigned char* dest, const u32* src, size_t num_bytes_to_reorder) {
    size_t num_regs_to_process = (num_bytes_to_reorder + 3) / 4;
    for (size_t i = 0; i < num_regs_to_process; i++) {
        u32 current_reg_val = src[RESULT_REG_COUNT - 1 - i];
        dest[i * 4 + 0] = (current_reg_val >> 24) & 0xFF;
        dest[i * 4 + 1] = (current_reg_val >> 16) & 0xFF;
        dest[i * 4 + 2] = (current_reg_val >> 8)  & 0xFF;
        dest[i * 4 + 3] = (current_reg_val >> 0)  & 0xFF;
    }
}

/************************** Helper Functions ***************************/
void print_hex_inline(const char *label, const unsigned char *data, size_t len) {
    xil_printf("%s: ", label);
    for (size_t i = 0; i < len; i++) { xil_printf("%02x", data[i]); }
    xil_printf("\r\n");
}
void init_platform() { Xil_ICacheEnable(); Xil_DCacheEnable(); }
void cleanup_platform() { Xil_DCacheDisable(); Xil_ICacheDisable(); }

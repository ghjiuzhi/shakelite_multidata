/******************************************************************************
*
* Copyright (C) 2009 - 2014 Xilinx, Inc.  All rights reserved.
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* Use of the Software is limited solely to applications:
* (a) running on a Xilinx device, or
* (b) that interact with a Xilinx device through a bus or interconnect.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
* XILINX  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
* OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
* SOFTWARE.
*
* Except as contained in this notice, the name of the Xilinx shall not be used
* in advertising or otherwise to promote the sale, use or other dealings in
* this Software without prior written authorization from Xilinx.
*
******************************************************************************/

#include "xparameters.h"
#include "xil_printf.h"
#include "xstatus.h"
#include "xil_cache.h"
#include "xil_io.h"
#include <string.h>

/* Include the low-level driver definitions */
#include "sha3_1003_tIP1.h"

/************************** Constant Definitions ***************************/
#define IP_CORE_BASEADDR        XPAR_SHA3_1003_TIP1_0_S0_AXI_BASEADDR

/* Register address offsets (from your working test code) */
#define REG_CONTROL_OFFSET      0x00
#define REG_DIN_LOW_OFFSET      0x04
#define REG_DIN_HIGH_OFFSET     0x08
#define REG_CONTROL2_OFFSET     0x0C
#define REG_STATUS_OFFSET       0x10
#define REG_RESULT_START_OFFSET 0x14

/* Control bit definitions (from your working test code) */
#define CONTROL_START_BIT       (1 << 3)
#define CONTROL2_LAST_DIN_BIT   (1 << 0)
#define CONTROL2_DIN_VALID_BIT  (1 << 5)
#define CONTROL2_DOUT_READY_BIT (1 << 6)
#define STATUS_RESULT_READY_BIT (1 << 5)

#define RESULT_REG_COUNT 42

/************************** Function Prototypes ****************************/
void init_platform();
void cleanup_platform();
int final_hardware_test(u32 base_addr);
void print_hex_inline(const char *label, const unsigned char *data, size_t len);
void reorder_and_swap_bytes(unsigned char* dest, const u32* src, size_t num_bytes_to_reorder);


/*****************************************************************************/
int main()
{
    int status;
    init_platform();

    xil_printf("\r\n--- Final Hardware SHAKE256 Golden Vector Test (Reversed Read Logic) ---\r\n");
    status = final_hardware_test(IP_CORE_BASEADDR);

    cleanup_platform();
    return status;
}

/*****************************************************************************/
int final_hardware_test(u32 base_addr)
{
    u32 status_reg;
    u32 result_regs[RESULT_REG_COUNT];
    unsigned char reordered_hardware_output[32];
    int i;
    int timeout = 1000000;

    /* The official SHAKE256("abc") hash result (first 32 bytes) */
    const unsigned char golden_output[32] = {
        0xad, 0x82, 0x62, 0x68, 0x2d, 0x30, 0xd2, 0x57, 0xc7, 0x3c, 0x24, 0x20,
        0x95, 0x20, 0x55, 0x61, 0x63, 0x35, 0xb3, 0x9e, 0x39, 0x4b, 0x3e, 0x0d,
        0x78, 0x3a, 0x9a, 0x7a, 0x21, 0x6e, 0x91, 0x9f
    };

    /* --- Step 1: Prepare "abc" input data --- */
    u64 write_data = 0x6162630000000000ULL;
    u32 high_32 = (u32)(write_data >> 32);
    u32 low_32  = (u32)(write_data & 0xFFFFFFFF);
    xil_printf("Step 1: Writing data for 'abc'...\r\n");
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_DIN_HIGH_OFFSET, high_32);
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_DIN_LOW_OFFSET, low_32);

    /* --- Step 2: Set control signals --- */
    u32 control2_val = CONTROL2_LAST_DIN_BIT | (3 << 1) | CONTROL2_DOUT_READY_BIT;
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL2_OFFSET, control2_val);
    xil_printf("Step 2: Setting control signals (byte count = 3)...\r\n");

    /* --- Step 3: Start computation --- */
    u32 control_val = 1; /* Mode 1: Shake-256 */
    xil_printf("Step 3: Initiating start sequence...\r\n");
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL_OFFSET, control_val);
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL_OFFSET, control_val | CONTROL_START_BIT);
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL_OFFSET, control_val);
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL2_OFFSET, control2_val | CONTROL2_DIN_VALID_BIT);
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL2_OFFSET, control2_val);

    /* --- Step 4: Wait for completion --- */
    xil_printf("Step 4: Waiting for hardware to complete...\r\n");
    do {
        status_reg = SHA3_1003_TIP1_mReadReg(base_addr, REG_STATUS_OFFSET);
        timeout--;
    } while (((status_reg & STATUS_RESULT_READY_BIT) == 0) && (timeout > 0));

    if (timeout <= 0) {
        xil_printf("  [ERROR] Timeout!\r\n");
        return XST_FAILURE;
    }
    xil_printf("  Calculation complete!\r\n");

    /* --- Step 5: Read and print all raw registers --- */
    xil_printf("\n--- Step 5: Reading raw result from all %d registers ---\r\n", RESULT_REG_COUNT);
    for (i = 0; i < RESULT_REG_COUNT; i++) {
        result_regs[i] = SHA3_1003_TIP1_mReadReg(base_addr, REG_RESULT_START_OFFSET + i * 4);
        xil_printf("  reg[%2d]: 0x%08X\r\n", i, result_regs[i]);
    }

    /* --- Step 6: Reorder data according to your description --- */
    xil_printf("\n--- Step 6: Reordering hardware output based on reverse-read logic ---\r\n");
    reorder_and_swap_bytes(reordered_hardware_output, result_regs, 32);

    /* --- Step 7: Final Verdict --- */
    xil_printf("\r\n--- Final Verdict ---\r\n");
    print_hex_inline("  Expected Output (Golden)", golden_output, 32);
    print_hex_inline("  Actual Reordered Output ", reordered_hardware_output, 32);

    if (memcmp(reordered_hardware_output, golden_output, 32) == 0) {
        xil_printf("\r\n[HARDWARE IP PASSED!] Your IP core and reverse-read logic are PERFECT.\r\n");
        return XST_SUCCESS;
    } else {
        xil_printf("\r\n[HARDWARE IP FAILED!] Even with reversed logic, the result is incorrect.\r\n");
        return XST_FAILURE;
    }
}

/**
 * @brief Reorders registers from back-to-front and handles endianness.
 * @param dest      Destination byte array.
 * @param src       Raw 32-bit register array from IP core.
 * @param num_bytes_to_reorder The number of final bytes to create.
 */
void reorder_and_swap_bytes(unsigned char* dest, const u32* src, size_t num_bytes_to_reorder) {
    size_t num_regs_to_process = (num_bytes_to_reorder + 3) / 4; // ceiling division
    for (size_t i = 0; i < num_regs_to_process; i++) {
        // Read registers from the end: reg[41], reg[40], ...
        u32 current_reg_val = src[RESULT_REG_COUNT - 1 - i];

        // The processor is Little Endian. We need to manually extract bytes in Big Endian order.
        // Convert a 32-bit integer 0xAABBCCDD into a byte array {AA, BB, CC, DD}
        dest[i * 4 + 0] = (current_reg_val >> 24) & 0xFF; // MSB
        dest[i * 4 + 1] = (current_reg_val >> 16) & 0xFF;
        dest[i * 4 + 2] = (current_reg_val >> 8)  & 0xFF;
        dest[i * 4 + 3] = (current_reg_val >> 0)  & 0xFF; // LSB
    }
}

/************************** Helper Functions ***************************/
void print_hex_inline(const char *label, const unsigned char *data, size_t len) {
    xil_printf("%s: ", label);
    for (size_t i = 0; i < len; i++) {
        xil_printf("%02x", data[i]);
    }
    xil_printf("\r\n");
}
void init_platform() {
    Xil_ICacheEnable();
    Xil_DCacheEnable();
}
void cleanup_platform() {
    Xil_DCacheDisable();
    Xil_ICacheDisable();
}

#include "fpga_sha_driver.h"
#include "xparameters.h"
#include "xil_io.h"
#include <string.h>
#include "sha3_1003_tIP1.h" // 包含底层宏定义

/* 从您已验证的测试代码中引用的定义 */
#define IP_CORE_BASEADDR        XPAR_SHA3_1003_TIP1_0_S0_AXI_BASEADDR
#define REG_CONTROL_OFFSET      0x00
#define REG_DIN_LOW_OFFSET      0x04
#define REG_DIN_HIGH_OFFSET     0x08
#define REG_CONTROL2_OFFSET     0x0C
#define REG_STATUS_OFFSET       0x10
#define REG_RESULT_START_OFFSET 0x14

/* 从您已验证的测试代码中引用的控制位定义 */
#define CONTROL_START_BIT       (1 << 3)
#define CONTROL2_LAST_DIN_BIT   (1 << 0)
#define CONTROL2_DIN_VALID_BIT  (1 << 5)
#define CONTROL2_DOUT_READY_BIT (1 << 6)
#define STATUS_RESULT_READY_BIT (1 << 5)

#define RESULT_REG_COUNT 42
#define MODE_SHAKE_256   1 // SHAKE-256 模式

/**
 * @brief 将硬件寄存器的输出从后向前重新排序，并处理字节序。
 * (此函数逻辑与您验证过的代码一致)
 */
static void reorder_and_swap_bytes(unsigned char* dest, const u32* src, size_t num_bytes_to_reorder) {
    size_t num_regs_to_process = (num_bytes_to_reorder + 3) / 4;
    for (size_t i = 0; i < num_regs_to_process; i++) {
        u32 current_reg_val = src[RESULT_REG_COUNT - 1 - i];
        dest[i * 4 + 0] = (current_reg_val >> 24) & 0xFF;
        dest[i * 4 + 1] = (current_reg_val >> 16) & 0xFF;
        dest[i * 4 + 2] = (current_reg_val >> 8)  & 0xFF;
        dest[i * 4 + 3] = (current_reg_val >> 0)  & 0xFF;
    }
}

/**
 * @brief 驱动 SHAKE256 硬件 IP (基于您已验证代码的最终修正版)
 */
void shake256_hw(uint8_t *out, size_t outlen, const uint8_t *in, const size_t inlen)
{
    u32 base_addr = IP_CORE_BASEADDR;
    size_t remaining_len = inlen;
    const uint8_t *data_ptr = in;
    int timeout;

    /* --- 步骤 1 & 2: 设置模式并发送启动脉冲 (完全仿照您的代码) --- */
    u32 control_val = (MODE_SHAKE_256 & 0x7);
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL_OFFSET, control_val);
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL_OFFSET, control_val | CONTROL_START_BIT);
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL_OFFSET, control_val);

    /* --- 步骤 3: 循环发送所有完整的8字节数据块 --- */
    while (remaining_len >= 8) {
        u64 chunk;
        // 使用memcpy确保在小端序的Zynq上字节序正确
        memcpy(&chunk, data_ptr, 8);

        SHA3_1003_TIP1_mWriteReg(base_addr, REG_DIN_HIGH_OFFSET, (u32)(chunk >> 32));
        SHA3_1003_TIP1_mWriteReg(base_addr, REG_DIN_LOW_OFFSET,  (u32)(chunk & 0xFFFFFFFF));

        // 为普通数据块发送 din_valid 脉冲 (last_din=0, dout_ready=0)
        u32 control2_val = (8 << 1); // 长度=8
        SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL2_OFFSET, control2_val | CONTROL2_DIN_VALID_BIT);
        SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL2_OFFSET, control2_val); // 清除 din_valid

        data_ptr += 8;
        remaining_len -= 8;
    }

    /* --- 步骤 4: 发送最后一个数据块 (可能是0-7字节) --- */
    u64 last_chunk = 0;
    if (remaining_len > 0) {
        memcpy(&last_chunk, data_ptr, remaining_len);
    }
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_DIN_HIGH_OFFSET, (u32)(last_chunk >> 32));
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_DIN_LOW_OFFSET,  (u32)(last_chunk & 0xFFFFFFFF));

    // 准备最后一个数据块的控制信号 (last_din=1, din_valid=1)
    u32 control2_final_data = CONTROL2_LAST_DIN_BIT | ((u32)remaining_len << 1) | CONTROL2_DIN_VALID_BIT;
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL2_OFFSET, control2_final_data);

    /* --- 步骤 5: 关键步骤！发送独立的“输入结束”信号 (完全仿照您的代码) --- */
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL2_OFFSET, CONTROL2_DOUT_READY_BIT);

    /* --- 步骤 6: 等待硬件计算完成 --- */
    timeout = 1000000;
    while (((SHA3_1003_TIP1_mReadReg(base_addr, REG_STATUS_OFFSET) & STATUS_RESULT_READY_BIT) == 0) && (timeout > 0)) {
        timeout--;
    }
    if (timeout <= 0) {
        xil_printf("[ERROR] Timeout waiting for hardware result in shake256_hw!\r\n");
        memset(out, 0xEE, outlen); // 用错误码填充输出以供调试
        return;
    }

    /* --- 步骤 7 & 8: 读取并重排结果 --- */
    u32 result_regs[RESULT_REG_COUNT];
    for (int i = 0; i < RESULT_REG_COUNT; i++) {
        result_regs[i] = SHA3_1003_TIP1_mReadReg(base_addr, REG_RESULT_START_OFFSET + i * 4);
    }

    unsigned char reordered_buffer[sizeof(result_regs)];
    reorder_and_swap_bytes(reordered_buffer, result_regs, sizeof(reordered_buffer));

    memcpy(out, reordered_buffer, outlen);
}

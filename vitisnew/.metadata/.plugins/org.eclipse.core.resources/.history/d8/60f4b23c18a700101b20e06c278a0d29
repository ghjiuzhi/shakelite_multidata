#include "fpga_sha_driver.h"
#include "xparameters.h"
#include "xil_io.h"
#include <string.h>

// 这些宏定义来自于你验证成功的 test_shake_abc.c
#define IP_CORE_BASEADDR        XPAR_SHA3_1003_TIP1_0_S0_AXI_BASEADDR
#define REG_CONTROL_OFFSET      0x00
#define REG_DIN_LOW_OFFSET      0x04
#define REG_DIN_HIGH_OFFSET     0x08
#define REG_CONTROL2_OFFSET     0x0C
#define REG_STATUS_OFFSET       0x10
#define REG_RESULT_START_OFFSET 0x14
#define CONTROL_START_BIT       (1 << 3)
#define CONTROL2_LAST_DIN_BIT   (1 << 0)
#define CONTROL2_DIN_VALID_BIT  (1 << 5)
#define CONTROL2_DOUT_READY_BIT (1 << 6)
#define STATUS_RESULT_READY_BIT (1 << 5)
#define RESULT_REG_COUNT 42

/**
 * @brief 使用 FPGA IP 核执行 SHAKE256 哈希运算 (最终正确版本)
 * 严格遵循经过验证的 test_shake_abc.c 中的控制逻辑
 */
void shake256_hw(uint8_t *out, size_t outlen, const uint8_t *in, const size_t inlen)
{
    u32 base_addr = IP_CORE_BASEADDR;
    size_t remaining_len = inlen;
    const uint8_t *data_ptr = in;
    int timeout;

    // --- 1. 设置模式和 dout_ready ---
    u32 control_val = 1; // Mode 1: Shake-256
    Xil_Out32(base_addr + REG_CONTROL_OFFSET, control_val);

    u32 control2_base = CONTROL2_DOUT_READY_BIT;
    Xil_Out32(base_addr + REG_CONTROL2_OFFSET, control2_base);

    // --- 2. 发送启动脉冲，初始化一次新操作 ---
    Xil_Out32(base_addr + REG_CONTROL_OFFSET, control_val | CONTROL_START_BIT);
    Xil_Out32(base_addr + REG_CONTROL_OFFSET, control_val);

    // --- 3. 以8字节为单位，流式传输大部分输入数据 ---
    while (remaining_len >= 8) {
        // 从内存中安全地复制8个字节
        u64 chunk;
        memcpy(&chunk, data_ptr, 8);

        // ** 正确的步骤：将64位数据拆分为两个32位值 **
        u32 high_32 = (u32)(chunk >> 32);
        u32 low_32  = (u32)(chunk & 0xFFFFFFFF);

        // ** 正确的步骤：通过两次32位写操作，写入64位数据 **
        Xil_Out32(base_addr + REG_DIN_HIGH_OFFSET, high_32);
        Xil_Out32(base_addr + REG_DIN_LOW_OFFSET,  low_32);

        // 发送 din_valid 脉冲，让IP核接收这64位数据
        Xil_Out32(base_addr + REG_CONTROL2_OFFSET, control2_base | CONTROL2_DIN_VALID_BIT);
        Xil_Out32(base_addr + REG_CONTROL2_OFFSET, control2_base);

        data_ptr += 8;
        remaining_len -= 8;
    }

    // --- 4. 发送最后的数据块（可能不足8字节） ---
    u64 last_chunk = 0;
    if (remaining_len > 0) {
        memcpy(&last_chunk, data_ptr, remaining_len);
    }

    // 同样，拆分为两次32位写操作
    u32 high_32_last = (u32)(last_chunk >> 32);
    u32 low_32_last  = (u32)(last_chunk & 0xFFFFFFFF);
    Xil_Out32(base_addr + REG_DIN_HIGH_OFFSET, high_32_last);
    Xil_Out32(base_addr + REG_DIN_LOW_OFFSET,  low_32_last);

    // 准备最后的控制字：包含LAST位和剩余的字节数
    u32 control2_final = control2_base | CONTROL2_LAST_DIN_BIT | ((u32)remaining_len << 1);
    Xil_Out32(base_addr + REG_CONTROL2_OFFSET, control2_final);

    // 发送最后的 din_valid 脉冲
    Xil_Out32(base_addr + REG_CONTROL2_OFFSET, control2_final | CONTROL2_DIN_VALID_BIT);
    Xil_Out32(base_addr + REG_CONTROL2_OFFSET, control2_final);

    // --- 5. 等待计算完成 ---
    timeout = 1000000;
    while (((Xil_In32(base_addr + REG_STATUS_OFFSET) & STATUS_RESULT_READY_BIT) == 0) && (timeout > 0)) {
        timeout--;
    }
    if (timeout <= 0) {
        // 如果发生超时，可以在这里加打印来报告错误
        return;
    }

    // --- 6. 读出结果 ---
    u32 result_buffer[RESULT_REG_COUNT];
    for (int i = 0; i < RESULT_REG_COUNT; i++) {
        result_buffer[i] = Xil_In32(base_addr + REG_RESULT_START_OFFSET + i * 4);
    }

    // 只复制算法需要的长度
    size_t copy_len = (outlen > sizeof(result_buffer)) ? sizeof(result_buffer) : outlen;
    memcpy(out, result_buffer, copy_len);
}

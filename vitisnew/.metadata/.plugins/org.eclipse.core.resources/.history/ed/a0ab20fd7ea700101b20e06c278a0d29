#include "randombytes.h"
#include "xtime_l.h" // 包含Xilinx的时间函数库
//此版用时间作为种子，随机性较高。
// xoroshiro128+ 的状态 (种子)  
static uint64_t s[2];

// 辅助函数：一个64位的 splitmix64 PRNG，用于给 xoroshiro128+ 初始化一个好的种子
static uint64_t splitmix64(uint64_t *x)
{
    uint64_t z = (*x += 0x9e3779b97f4a7c15);
    z = (z ^ (z >> 30)) * 0xbf58476d1ce4e5b9;
    z = (z ^ (z >> 27)) * 0x94d049bb133111eb;
    return z ^ (z >> 31);
}

// xoroshiro128+ 核心生成函数
static uint64_t next(void)
{
    const uint64_t s0 = s[0];
    uint64_t s1 = s[1];
    const uint64_t result = s0 + s1;

    s1 ^= s0;
    s[0] = ((s0 << 24) | (s0 >> (64 - 24))) ^ s1 ^ (s1 << 16); // a, b = 24, 16
    s[1] = (s1 << 37) | (s1 >> (64 - 37)); // c = 37

    return result;
}

void randombytes(unsigned char *x, unsigned long long xlen)
{
    // 检查种子是否已经初始化 (如果s[0]和s[1]都是0，我们就初始化它)
    if (s[0] == 0 && s[1] == 0) {
        XTime t;
        XTime_GetTime(&t); // 获取当前64位的时钟节拍计数
        uint64_t seed = t;

        // 使用splitmix64为xoroshiro128+生成两个高质量的初始状态值
        s[0] = splitmix64(&seed);
        s[1] = splitmix64(&seed);
    }

    for (unsigned long long i = 0; i < xlen; i++) {
        // 每8个字节（64位）生成一次
        if (i % 8 == 0) {
            uint64_t rand_val = next();
            // 将64位的随机数逐字节地填充到输出数组中
            for (int j = 0; j < 8 && (i + j) < xlen; j++) {
                x[i + j] = (unsigned char)(rand_val >> (j * 8));
            }
        }
    }
}

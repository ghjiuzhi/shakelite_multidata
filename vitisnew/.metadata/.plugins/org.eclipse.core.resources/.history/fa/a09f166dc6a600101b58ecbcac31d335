#include "fpga_sha_driver.h"
#include "xparameters.h"
#include "xil_io.h"
#include <string.h> // For memcpy

// Constant definitions from your successful test code
#define IP_CORE_BASEADDR        XPAR_SHA3_1003_TIP1_0_S0_AXI_BASEADDR

// Register address offsets
#define REG_CONTROL_OFFSET      0x00
#define REG_DIN_LOW_OFFSET      0x04
#define REG_DIN_HIGH_OFFSET     0x08
#define REG_CONTROL2_OFFSET     0x0C
#define REG_STATUS_OFFSET       0x10
#define REG_RESULT_START_OFFSET 0x14

// Control bit definitions
#define CONTROL_START_BIT       (1 << 3)
#define CONTROL2_LAST_DIN_BIT   (1 << 0)
#define CONTROL2_DIN_VALID_BIT  (1 << 5)
#define CONTROL2_DOUT_READY_BIT (1 << 6)
#define STATUS_RESULT_READY_BIT (1 << 5)

// The total number of 32-bit registers holding the result state
#define RESULT_REG_COUNT 42

/**
 * @brief Core function to drive the SHAKE256 hardware IP.
 */
void shake256_hw(uint8_t *out, size_t outlen, const uint8_t *in, const size_t inlen)
{
    u32 base_addr = IP_CORE_BASEADDR;
    size_t remaining_len = inlen;
    const uint8_t *data_ptr = in;
    int timeout;

    // --- Step 1: Set Mode and dout_ready ---
    // Mode 1: Shake-256
    u32 control_val = 1;
    Xil_Out32(base_addr + REG_CONTROL_OFFSET, control_val);

    // Set dout_ready high. It will be kept high throughout the process.
    u32 control2_base = CONTROL2_DOUT_READY_BIT;
    Xil_Out32(base_addr + REG_CONTROL2_OFFSET, control2_base);

    // --- Step 2: Pulse Start to initialize the IP state machine ---
    Xil_Out32(base_addr + REG_CONTROL_OFFSET, control_val | CONTROL_START_BIT);
    Xil_Out32(base_addr + REG_CONTROL_OFFSET, control_val);

    // --- Step 3: Stream input data in 8-byte (64-bit) chunks ---
    while (remaining_len > 8) {
        u64 chunk;
        memcpy(&chunk, data_ptr, 8); // Safely copy 8 bytes

        // Write the 64-bit chunk to the DIN registers
        Xil_Out32(base_addr + REG_DIN_LOW_OFFSET, (u32)(chunk & 0xFFFFFFFF));
        Xil_Out32(base_addr + REG_DIN_HIGH_OFFSET, (u32)(chunk >> 32));

        // Pulse din_valid to tell the IP to consume this chunk
        Xil_Out32(base_addr + REG_CONTROL2_OFFSET, control2_base | CONTROL2_DIN_VALID_BIT);
        Xil_Out32(base_addr + REG_CONTROL2_OFFSET, control2_base);

        data_ptr += 8;
        remaining_len -= 8;
    }

    // --- Step 4: Send the final data chunk (1 to 8 bytes) ---
    u64 last_chunk = 0;
    if (remaining_len > 0) {
        memcpy(&last_chunk, data_ptr, remaining_len);
    }

    // Write the last chunk data
    Xil_Out32(base_addr + REG_DIN_LOW_OFFSET, (u32)(last_chunk & 0xFFFFFFFF));
    Xil_Out32(base_addr + REG_DIN_HIGH_OFFSET, (u32)(last_chunk >> 32));

    // Prepare control2 with LAST bit and valid byte count for the final pulse
    u32 control2_final = control2_base | CONTROL2_LAST_DIN_BIT | ((u32)remaining_len << 1);
    Xil_Out32(base_addr + REG_CONTROL2_OFFSET, control2_final);

    // Pulse din_valid for the last time
    Xil_Out32(base_addr + REG_CONTROL2_OFFSET, control2_final | CONTROL2_DIN_VALID_BIT);
    Xil_Out32(base_addr + REG_CONTROL2_OFFSET, control2_final);


    // --- Step 5: Wait for the result to be ready ---
    timeout = 1000000;
    while (((Xil_In32(base_addr + REG_STATUS_OFFSET) & STATUS_RESULT_READY_BIT) == 0) && (timeout > 0)) {
        timeout--;
    }
    // You can add error handling here if timeout occurs

    // --- Step 6: Read the required output data ---
    // The IP provides the full internal state (1344 bits). We only read the part we need (outlen).
    u32 result_buffer[RESULT_REG_COUNT];
    for (int i = 0; i < RESULT_REG_COUNT; i++) {
        result_buffer[i] = Xil_In32(base_addr + REG_RESULT_START_OFFSET + i * 4);
    }

    // Copy the required number of bytes to the output buffer
    memcpy(out, result_buffer, outlen);
}

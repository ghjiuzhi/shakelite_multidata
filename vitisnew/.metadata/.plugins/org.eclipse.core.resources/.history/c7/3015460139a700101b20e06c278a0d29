#include "fpga_sha_driver.h"
#include "xparameters.h"
#include "xil_io.h"
#include <string.h>
#include "sha3_1003_tIP1.h" // 包含底层宏定义

/* 从您已验证的测试代码中引用的定义 */
#define IP_CORE_BASEADDR        XPAR_SHA3_1003_TIP1_0_S0_AXI_BASEADDR
#define REG_CONTROL_OFFSET      0x00
#define REG_DIN_LOW_OFFSET      0x04
#define REG_DIN_HIGH_OFFSET     0x08
#define REG_CONTROL2_OFFSET     0x0C
#define REG_STATUS_OFFSET       0x10
#define REG_RESULT_START_OFFSET 0x14
#define CONTROL_START_BIT       (1 << 3)
#define CONTROL2_LAST_DIN_BIT   (1 << 0)
#define CONTROL2_DIN_VALID_BIT  (1 << 5)
#define CONTROL2_DOUT_READY_BIT (1 << 6)
#define STATUS_RESULT_READY_BIT (1 << 5)
#define RESULT_REG_COUNT 42

/**
 * @brief 将硬件寄存器的输出从后向前重新排序，并处理字节序。
 */
static void reorder_hardware_output(unsigned char* dest, const u32* src_regs, size_t bytes_to_copy) {
    size_t num_regs_to_process = (bytes_to_copy + 3) / 4;
    for (size_t i = 0; i < num_regs_to_process; i++) {
        u32 current_reg_val = src_regs[RESULT_REG_COUNT - 1 - i];
        dest[i * 4 + 0] = (current_reg_val >> 24) & 0xFF;
        dest[i * 4 + 1] = (current_reg_val >> 16) & 0xFF;
        dest[i * 4 + 2] = (current_reg_val >> 8)  & 0xFF;
        dest[i * 4 + 3] = (current_reg_val >> 0)  & 0xFF;
    }
}

/**
 * @brief 驱动 SHAKE256 硬件 IP (最终修正版)
 *
 * 核心修正:
 * 1. 字节序: 直接使用memcpy将字节流复制到u64中，依赖于Zynq处理器的小端序特性，
 * 确保与软件实现一致，取代了之前错误的大端序位移操作。
 * 2. “最后一块”逻辑: 简化了循环，在处理最后一个数据块（无论是满8字节还是不足8字节）
 * 时，一次性正确地设置 `LAST_DIN` 标志和长度，避免了发送多余的空块。
 * 3. 零长度输入: 增加了对输入长度为0的特殊情况处理。
 */
void shake256_hw(uint8_t *out, size_t outlen, const uint8_t *in, size_t inlen)
{
    u32 base_addr = IP_CORE_BASEADDR;
    size_t remaining_len = inlen;
    const uint8_t *data_ptr = in;
    int timeout;

    // 1. 初始化并启动IP核
    u32 control_val = 1; // Mode 1: Shake-256
    Xil_Out32(base_addr + REG_CONTROL_OFFSET, control_val);

    u32 control2_base = CONTROL2_DOUT_READY_BIT;
    Xil_Out32(base_addr + REG_CONTROL2_OFFSET, control2_base);

    Xil_Out32(base_addr + REG_CONTROL_OFFSET, control_val | CONTROL_START_BIT);
    Xil_Out32(base_addr + REG_CONTROL_OFFSET, control_val);

    // 2. 循环处理输入数据
    while (remaining_len > 0) {
        u64 chunk = 0;
        size_t bytes_in_this_chunk;
        u32 current_control2 = control2_base;

        if (remaining_len >= 8) {
            bytes_in_this_chunk = 8;
        } else {
            bytes_in_this_chunk = remaining_len;
        }

        // **字节序修正**: 直接内存复制，以匹配Zynq的小端序架构
        memcpy(&chunk, data_ptr, bytes_in_this_chunk);

        // **“最后一块”逻辑修正**: 如果这是最后一个数据块，就设置标志
        if (remaining_len <= 8) {
            current_control2 |= CONTROL2_LAST_DIN_BIT | ((u32)bytes_in_this_chunk << 1);
        }

        // 写入数据寄存器 (高低32位)
        Xil_Out32(base_addr + REG_DIN_HIGH_OFFSET, (u32)(chunk >> 32));
        Xil_Out32(base_addr + REG_DIN_LOW_OFFSET,  (u32)(chunk & 0xFFFFFFFF));

        // 发送 `din_valid` 脉冲，同时携带控制信息
        Xil_Out32(base_addr + REG_CONTROL2_OFFSET, current_control2 | CONTROL2_DIN_VALID_BIT);
        Xil_Out32(base_addr + REG_CONTROL2_OFFSET, current_control2);

        // 更新指针和剩余长度
        data_ptr += bytes_in_this_chunk;
        remaining_len -= bytes_in_this_chunk;
    }

    // **零长度输入处理**: 显式处理输入长度为0的特殊情况
    if (inlen == 0) {
        u32 control2_final = control2_base | CONTROL2_LAST_DIN_BIT; // 长度为0
        Xil_Out32(base_addr + REG_DIN_HIGH_OFFSET, 0);
        Xil_Out32(base_addr + REG_DIN_LOW_OFFSET, 0);
        Xil_Out32(base_addr + REG_CONTROL2_OFFSET, control2_final | CONTROL2_DIN_VALID_BIT);
        Xil_Out32(base_addr + REG_CONTROL2_OFFSET, control2_final);
    }

    // 3. 等待硬件计算完成
    timeout = 1000000;
    while (((Xil_In32(base_addr + REG_STATUS_OFFSET) & STATUS_RESULT_READY_BIT) == 0) && (timeout > 0)) {
        timeout--;
    }
    if (timeout <= 0) {
        xil_printf("[ERROR] Timeout waiting for hardware result in shake256_hw!\r\n");
        return;
    }

    // 4. 读取并重排结果
    u32 result_regs[RESULT_REG_COUNT];
    for (int i = 0; i < RESULT_REG_COUNT; i++) {
        result_regs[i] = Xil_In32(base_addr + REG_RESULT_START_OFFSET + i * 4);
    }

    unsigned char reordered_buffer[sizeof(result_regs)];
    reorder_hardware_output(reordered_buffer, result_regs, sizeof(reordered_buffer));

    // 5. 复制所需长度的输出
    memcpy(out, reordered_buffer, outlen);
}

#include <stdio.h>
#include <string.h>
#include "xil_printf.h"
#include "xil_types.h"
#include "xstatus.h"
#include "xil_cache.h"
#include "xtime_l.h"

// 包含SPHINCS+的所有核心文件
#include "api.h"
#include "params.h"
#include "wots.h"
#include "fors.h"
#include "utils.h"

// 这是一个编译时检查，如果PARAMS宏没有正确设置，编译会直接报错
#if !defined(CRYPTO_BYTES) || !defined(SPX_N)
    #error "SPHINCS+ parameters not loaded correctly. Check params.h and build settings."
#endif

#define MESSAGE_LEN 32

/************************** 函数声明 ***************************/
void print_hex(const char *label, const unsigned char *data, size-t len);
int run_sphincs_test_forensic(); // 使用新的法证调试函数
void init_platform();
void cleanup_platform();

// 声明外部的硬件驱动函数，以便我们可以在这里调用它
extern void shake256_hw(uint8_t *out, size_t outlen, const uint8_t *in, const size_t inlen);


/*****************************************************************************/
int main()
{
    int status;
    init_platform();

    xil_printf("\r\n\n--- SPHINCS+ FORENSIC DEBUGGING TEST ---\r\n");
    xil_printf("This test will print detailed steps to locate the failure point.\r\n");
    xil_printf("SPHINCS+ Parameter Set: %s\r\n", xstr(PARAMS));
    xil_printf("Expected Signature Bytes (CRYPTO_BYTES): %d\r\n\n", CRYPTO_BYTES);

    status = run_sphincs_test_forensic();

    if (status == XST_SUCCESS) {
        xil_printf("\r\n[TRUE SUCCESS] All steps completed and verified successfully!\r\n");
    } else {
        xil_printf("\r\n[EXECUTION FAILED] The test failed at one of the steps above.\r\n");
    }

    cleanup_platform();
    return status;
}

/*****************************************************************************/
int run_sphincs_test_forensic()
{
    static unsigned char pk[CRYPTO_PUBLICKEYBYTES];
    static unsigned char sk[CRYPTO_SECRETKEYBYTES];
    static unsigned char m[MESSAGE_LEN];
    static unsigned char sm[CRYPTO_BYTES + MESSAGE_LEN];
    static unsigned char mout[CRYPTO_BYTES + MESSAGE_LEN];

    unsigned long long smlen;
    unsigned long long mlen_out;
    int ret_val;
    XTime t_start, t_end;

    xil_printf("--- Step 1: Preparing a %d-byte message ---\r\n", MESSAGE_LEN);
    for (int i = 0; i < MESSAGE_LEN; i++) { m[i] = (unsigned char)i; }
    print_hex("  Original Message", m, MESSAGE_LEN);

    xil_printf("\r\n--- Step 2: Generating keypair (PK: %d bytes, SK: %d bytes) ---\r\n", CRYPTO_PUBLICKEYBYTES, CRYPTO_SECRETKEYBYTES);
    XTime_GetTime(&t_start);
    if (crypto_sign_keypair(pk, sk) != 0) {
        xil_printf("  [ERROR] Keypair generation failed!\r\n");
        return XST_FAILURE;
    }
    XTime_GetTime(&t_end);
    xil_printf("  Keypair generated successfully in %llu clock cycles.\r\n", (unsigned long long)(t_end - t_start));
    print_hex("  Public Key (first 32 bytes)", pk, 32);

    xil_printf("\r\n--- Step 3: Signing the message ---\r\n");
    xil_printf("  The signing process involves many hash calls. We will trace the main steps.\r\n");
    XTime_GetTime(&t_start);
    if (crypto_sign(sm, &smlen, m, MESSAGE_LEN, sk) != 0) {
        xil_printf("  [ERROR] crypto_sign function returned an error!\r\n");
        return XST_FAILURE;
    }
    XTime_GetTime(&t_end);
    xil_printf("  crypto_sign function completed in %llu clock cycles.\r\n", (unsigned long long)(t_end - t_start));
    xil_printf("  Reported total signed message length: %llu bytes.\r\n", smlen);

    // --- 绝对可靠的长度检查 ---
    const unsigned long long expected_smlen = CRYPTO_BYTES + MESSAGE_LEN;
    if (smlen != expected_smlen) {
        xil_printf("\r\n  [CRITICAL FAILURE] Signature length is INCORRECT!\r\n");
        xil_printf("    Expected total length: %llu bytes\r\n", expected_smlen);
        xil_printf("    Actual total length:   %llu bytes\r\n", smlen);
        xil_printf("    This is the definitive proof that the hardware accelerator is producing incorrect hash values.\r\n");
        return XST_FAILURE;
    }
    xil_printf("  Signature length is CORRECT.\r\n");
    print_hex("  Signature part (first 32 bytes)", sm, 32);

    xil_printf("\r\n--- Step 4: Verifying the signature ---\r\n");
    XTime_GetTime(&t_start);
    ret_val = crypto_sign_open(mout, &mlen_out, sm, smlen, pk);
    XTime_GetTime(&t_end);

    if (ret_val != 0) {
        xil_printf("  [ERROR] Verification function returned code %d! Signature is INVALID.\r\n", ret_val);
        return XST_FAILURE;
    }
    xil_printf("  Signature verified successfully in %llu clock cycles.\r\n", (unsigned long long)(t_end - t_start));

    xil_printf("\r\n--- Step 5: Final Check ---\r\n");
    if (mlen_out != MESSAGE_LEN || memcmp(m, mout, MESSAGE_LEN) != 0) {
        xil_printf("  [ERROR] Message content mismatch! Original and recovered messages are different.\r\n");
        return XST_FAILURE;
    }
    xil_printf("  Original and recovered messages match perfectly.\r\n");

    return XST_SUCCESS;
}

/************************** 辅助函数 ***************************/
void print_hex(const char *label, const unsigned char *data, size_t len) {
    xil_printf("%s: ", label);
    for (size_t i = 0; i < len; i++) {
        xil_printf("%02x", data[i]);
    }
    xil_printf("\r\n");
}

void init_platform() {
    Xil_DCacheDisable();
    Xil_ICacheEnable();
    Xil_DCacheEnable();
}

void cleanup_platform() {
    Xil_DCacheDisable();
    Xil_ICacheDisable();
}

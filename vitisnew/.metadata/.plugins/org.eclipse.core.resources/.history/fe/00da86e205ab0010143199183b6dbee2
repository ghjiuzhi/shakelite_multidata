#include "fpga_sha_driver.h"
#include "xparameters.h"
#include "xil_io.h"
#include <string.h>
#include "sha3_1003_tIP1.h" // 包含底雍甓x

/* 哪已C的y代a中引用的定x */
#define IP_CORE_BASEADDR        XPAR_SHA3_1003_TIP1_0_S0_AXI_BASEADDR
#define REG_CONTROL_OFFSET      0x00
#define REG_DIN_LOW_OFFSET      0x04
#define REG_DIN_HIGH_OFFSET     0x08
#define REG_CONTROL2_OFFSET     0x0C
#define REG_STATUS_OFFSET       0x10
#define REG_RESULT_START_OFFSET 0x14

/* 哪已C的y代a中引用的控制位定x */
#define CONTROL_START_BIT       (1 << 3)
#define CONTROL2_LAST_DIN_BIT   (1 << 0)
#define CONTROL2_DIN_VALID_BIT  (1 << 5)
#define CONTROL2_DOUT_READY_BIT (1 << 6)
#define STATUS_RESULT_READY_BIT (1 << 5)

#define RESULT_REG_COUNT 42
#define MODE_SHAKE_256   1 // SHAKE-256 模式

/**
 * @brief ⒂布寄存器的出尼嵯蚯爸匦屡判颍K理字序。
 */
static void reorder_and_swap_bytes(unsigned char* dest, const u32* src, size_t num_bytes_to_reorder) {
    size_t num_regs_to_process = (num_bytes_to_reorder + 3) / 4;
    for (size_t i = 0; i < num_regs_to_process; i++) {
        u32 current_reg_val = src[RESULT_REG_COUNT - 1 - i];
        dest[i * 4 + 0] = (current_reg_val >> 24) & 0xFF;
        dest[i * 4 + 1] = (current_reg_val >> 16) & 0xFF;
        dest[i * 4 + 2] = (current_reg_val >> 8)  & 0xFF;
        dest[i * 4 + 3] = (current_reg_val >> 0)  & 0xFF;
    }
}

/**
 * @brief  SHAKE256 硬件 IP (最K修正版 - 栏褡裱已C)10.17.10：56在后面加上real来在main中实现时间开销的计算
 */
void shake256_hw_real(uint8_t *out, size_t outlen, const uint8_t *in, const size_t inlen)
{
    u32 base_addr = IP_CORE_BASEADDR;
    size_t remaining_len = inlen;
    const uint8_t *data_ptr = in;
    int timeout;

    /* --- 步E 1 & 2: O置模式Kl送用}_ (完全仿照您的代a) --- */
    u32 control_val = (MODE_SHAKE_256 & 0x7);
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL_OFFSET, control_val);
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL_OFFSET, control_val | CONTROL_START_BIT);
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL_OFFSET, control_val);

    /* --- 步E 3: 循hl送K --- */
    while (remaining_len > 0) {
        u64 chunk = 0;
        size_t bytes_to_process = (remaining_len >= 8) ? 8 : remaining_len;

        // **正_的大端序加d** (基於您部分成功的代a)
        for (size_t i = 0; i < bytes_to_process; i++) {
            chunk |= (u64)data_ptr[i] << (56 - (i * 8));
        }

        SHA3_1003_TIP1_mWriteReg(base_addr, REG_DIN_HIGH_OFFSET, (u32)(chunk >> 32));
        SHA3_1003_TIP1_mWriteReg(base_addr, REG_DIN_LOW_OFFSET,  (u32)(chunk & 0xFFFFFFFF));

        // **正_的控制流** (基於您成功\行的y代a)
        if (remaining_len <= 8) {
            // @是最後一K
            u32 control2_final = CONTROL2_LAST_DIN_BIT | ((u32)bytes_to_process << 1);
            SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL2_OFFSET, control2_final | CONTROL2_DIN_VALID_BIT);
            SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL2_OFFSET, CONTROL2_DOUT_READY_BIT); // 立即l送Y束信
        } else {
            // @不是最後一K
            u32 control2_val = (8 << 1); //L度8
            SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL2_OFFSET, control2_val | CONTROL2_DIN_VALID_BIT);
            SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL2_OFFSET, control2_val);
        }

        data_ptr += bytes_to_process;
        remaining_len -= bytes_to_process;
    }

    // **理入0的特殊情r**
    if (inlen == 0) {
        SHA3_1003_TIP1_mWriteReg(base_addr, REG_DIN_HIGH_OFFSET, 0);
        SHA3_1003_TIP1_mWriteReg(base_addr, REG_DIN_LOW_OFFSET,  0);
        u32 control2_final = CONTROL2_LAST_DIN_BIT | (0 << 1); // L度0
        SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL2_OFFSET, control2_final | CONTROL2_DIN_VALID_BIT);
        SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL2_OFFSET, CONTROL2_DOUT_READY_BIT);
    }

    /* --- 步E 4: 等待硬件算完成 --- */
    timeout = 1000000;
    while (((SHA3_1003_TIP1_mReadReg(base_addr, REG_STATUS_OFFSET) & STATUS_RESULT_READY_BIT) == 0) && (timeout > 0)) {
        timeout--;
    }
    if (timeout <= 0) {
        xil_printf("[ERROR] Timeout waiting for hardware result in shake256_hw!\r\n");
        memset(out, 0xEE, outlen);
        return;
    }

    /* --- 步E 5: x取K重排Y果 --- */
    u32 result_regs[RESULT_REG_COUNT];
    for (int i = 0; i < RESULT_REG_COUNT; i++) {
        result_regs[i] = SHA3_1003_TIP1_mReadReg(base_addr, REG_RESULT_START_OFFSET + i * 4);
    }

    unsigned char reordered_buffer[sizeof(result_regs)];
    reorder_and_swap_bytes(reordered_buffer, result_regs, sizeof(reordered_buffer));

    memcpy(out, reordered_buffer, outlen);
}

/***************************** Include Files *******************************/

#include "xparameters.h"
#include "xil_printf.h"
#include "xstatus.h"
#include "xil_cache.h"
#include "xil_io.h"
#include "sha3_1003_tIP1.h" // IP核的驱动头文件

/************************** Constant Definitions ***************************/

#define IP_CORE_BASEADDR XPAR_SHA3_1003_TIP1_0_S0_AXI_BASEADDR

// 根据Verilog文件定义寄存器地址偏移
#define REG_CONTROL_OFFSET      0x00 // slv_reg0: mode, start, hold
#define REG_DIN_LOW_OFFSET      0x04 // slv_reg1: 数据输入低32位
#define REG_DIN_HIGH_OFFSET     0x08 // slv_reg2: 数据输入高32位
#define REG_CONTROL2_OFFSET     0x0C // slv_reg3: last_din, din_valid, etc.
#define REG_STATUS_OFFSET       0x10 // slv_reg4: 状态寄存器 (busy, done)
#define REG_RESULT_START_OFFSET 0x14 // 结果寄存器的起始地址

// 根据Verilog文件定义控制位
#define CONTROL_START_BIT       (1 << 3) // slv_reg0[3] 是 start_i
#define CONTROL2_LAST_DIN_BIT   (1 << 0) // slv_reg3[0] 是 last_din_i
#define CONTROL2_DIN_VALID_BIT  (1 << 5) // slv_reg3[5] 是 din_valid_i
#define CONTROL2_DOUT_READY_BIT (1 << 6) // slv_reg3[6] 是 dout_ready_i

// **【关键修正】** 将状态位定义移至全局
#define STATUS_RESULT_READY_BIT (1 << 5) // slv_reg4[5] 是 result_ready_flag

#define RESULT_REG_COUNT 42 // 共有42个32位结果寄存器

/************************** Function Prototypes ****************************/
void init_platform();
void cleanup_platform();
int test_sha3_256_abc(u32 base_addr);

/*****************************************************************************/
/**
* @brief 主函数
******************************************************************************/
int main()
{
    int status;
    init_platform();

    xil_printf("\r\n--- SHA3_1003_TIP1 IP Core - 哈希计算与结果读取测试 ---\r\n");

    // 我们只调用修正后的函数
    status = test_sha3_256_abc(IP_CORE_BASEADDR);

    if (status == XST_SUCCESS) {
        xil_printf("\r\n[成功] 哈希计算和结果读取测试完成!\r\n");
    } else {
        xil_printf("\r\n[失败] 测试过程中发生错误!\r\n");
    }

    cleanup_platform();
    return status;
}

/*****************************************************************************/
/**
* @brief    测试 SHAKE-256，并读取全部1344位硬件输出。(根据Verilog时序修正)
*
* @param    base_addr 是IP核的基地址。
*
* @return   - XST_SUCCESS: 成功 / - XST_FAILURE: 失败
******************************************************************************/
int test_sha3_256_abc(u32 base_addr)
{
    // --- 步骤 1: 准备输入数据 ---
    u64 write_data = 0x11223344AABBCCDD; // 您代码中使用的测试数据
    u32 low_32 = (u32)write_data;
    u32 high_32 = (u32)(write_data >> 32);
    u32 status_reg;
    u32 result_buffer[RESULT_REG_COUNT];
    int i;
    int timeout = 1000000;

    xil_printf("\r\n--- SHAKE-256 最终调试 (已根据Verilog时序修正) ---\r\n");
    xil_printf("步骤 1: 准备写入的数据 (高32位: 0x%08X, 低32位: 0x%08X)\r\n", high_32, low_32);
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_DIN_LOW_OFFSET, low_32);
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_DIN_HIGH_OFFSET, high_32);

    // --- 步骤 2: 设置静态控制信号 ---
    // 设置 last_din, last_din_byte, dout_ready，但保持 din_valid 为低
    // 假设您的有效字节数为8 (64位)
    u32 control2_val = CONTROL2_LAST_DIN_BIT | (8 << 1) | CONTROL2_DOUT_READY_BIT;
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL2_OFFSET, control2_val);
    xil_printf("步骤 2: 设置 slv_reg3 (值为 0x%08X), 指定有效字节数为8\r\n", control2_val);

    // --- 步骤 3: 【关键】按照Verilog要求的时序启动计算 ---
    // 根据Verilog代码，硬件需要先接收到 start_i，进入 ABSORB 状态，
    // 然后再检测到 din_valid_i 的上升沿脉冲，才会锁存数据。
    u32 control_val = 1; // 模式1: Shake-256
    xil_printf("步骤 3: 设置模式为 Shake-256 (slv_reg0=%d) 并启动\r\n", control_val);

    // 3.1: 确保 start 和 din_valid 都为低，并设置好模式
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL_OFFSET, control_val);

    // 3.2: 发送 start 信号，让硬件状态机进入“准备接收数据”的状态
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL_OFFSET, control_val | CONTROL_START_BIT);
    xil_printf("  - 已发送 Start 信号，IP核应进入 ABSORB 状态。\r\n");

    // 3.3: 在 Start 之后，发送一个 din_valid 的“上升沿脉冲”来触发数据锁存
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL2_OFFSET, control2_val | CONTROL2_DIN_VALID_BIT); // 拉高 din_valid
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL2_OFFSET, control2_val);                         // 立即拉低，形成脉冲
    xil_printf("  - 已发送 din_valid 脉冲，数据应已被IP核锁存。\r\n");

    // 3.4: （可选但推荐）将 start 信号拉低，完成握手
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL_OFFSET, control_val);

    // --- 步骤 4: 等待计算完成 ---
    xil_printf("步骤 4: 等待计算完成...\r\n");
    do {
        status_reg = SHA3_1003_TIP1_mReadReg(base_addr, REG_STATUS_OFFSET);
        timeout--;
    } while (((status_reg & STATUS_RESULT_READY_BIT) == 0) && (timeout > 0));

    if (timeout <= 0) {
        xil_printf("  - [错误] 等待超时! 状态寄存器: 0x%08X\r\n", status_reg);
        return XST_FAILURE;
    }
    xil_printf("  - 计算完成! 状态寄存器: 0x%08X\r\n", status_reg);

    // --- 步骤 5 & 6: 读取并打印全部1344位结果 ---
    xil_printf("步骤 5: 读取全部1344位的哈希结果\r\n");
    xil_printf("  --- 哈希结果 ---\r\n");
    for (i = 0; i < RESULT_REG_COUNT; i++) {
        result_buffer[i] = SHA3_1003_TIP1_mReadReg(base_addr, REG_RESULT_START_OFFSET + i * 4);
        xil_printf("    reg[%2d]: 0x%08X\r\n", i, result_buffer[i]);
    }

    return XST_SUCCESS;
}

/*****************************************************************************/
/**
* @brief    平台初始化
******************************************************************************/
void init_platform()
{
    Xil_ICacheEnable();
    Xil_DCacheEnable();
}

/*****************************************************************************/
/**
* @brief    平台清理
******************************************************************************/
void cleanup_platform()
{
    Xil_DCacheDisable();
    Xil_ICacheDisable();
}

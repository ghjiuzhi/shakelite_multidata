#include "fpga_sha_driver.h"
#include "xparameters.h"
#include "xil_io.h"
#include <string.h>
#include "sha3_1003_tIP1.h" // Includes low-level macros

/* Register address offsets from your working test code */
#define IP_CORE_BASEADDR        XPAR_SHA3_1003_TIP1_0_S0_AXI_BASEADDR
#define REG_CONTROL_OFFSET      0x00
#define REG_DIN_LOW_OFFSET      0x04
#define REG_DIN_HIGH_OFFSET     0x08
#define REG_CONTROL2_OFFSET     0x0C
#define REG_STATUS_OFFSET       0x10
#define REG_RESULT_START_OFFSET 0x14

/* Control bit definitions from your working test code */
#define CONTROL_START_BIT       (1 << 3)
#define CONTROL2_LAST_DIN_BIT   (1 << 0)
#define CONTROL2_DIN_VALID_BIT  (1 << 5)
#define CONTROL2_DOUT_READY_BIT (1 << 6)
#define STATUS_RESULT_READY_BIT (1 << 5)

#define RESULT_REG_COUNT 42
#define MODE_SHAKE_256   1 // Mode is SHAKE-256

/**
 * @brief Reorders registers from back-to-front and handles endianness,
 * exactly as in your verified test code.
 */
static void reorder_and_swap_bytes(unsigned char* dest, const u32* src, size_t num_bytes_to_reorder) {
    size_t num_regs_to_process = (num_bytes_to_reorder + 3) / 4;
    for (size_t i = 0; i < num_regs_to_process; i++) {
        u32 current_reg_val = src[RESULT_REG_COUNT - 1 - i];
        dest[i * 4 + 0] = (current_reg_val >> 24) & 0xFF;
        dest[i * 4 + 1] = (current_reg_val >> 16) & 0xFF;
        dest[i * 4 + 2] = (current_reg_val >> 8)  & 0xFF;
        dest[i * 4 + 3] = (current_reg_val >> 0)  & 0xFF;
    }
}

/**
 * @brief Drives the SHAKE256 hardware IP.
 * This version is a direct implementation of the logic from your
 * verified `final_hardware_test` function.
 */
void shake256_hw(uint8_t *out, size_t outlen, const uint8_t *in, size_t inlen)
{
    u32 base_addr = IP_CORE_BASEADDR;
    size_t remaining_len = inlen;
    const uint8_t *data_ptr = in;
    int timeout;

    /* --- Step 1 & 2: Set mode and send a start pulse --- */
    u32 control_val = (MODE_SHAKE_256 & 0x7);
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL_OFFSET, control_val);
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL_OFFSET, control_val | CONTROL_START_BIT);
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL_OFFSET, control_val);

    /* --- Process all full 8-byte blocks --- */
    while (remaining_len >= 8) {
        u64 chunk;
        // memcpy ensures correct little-endian byte loading on Zynq
        memcpy(&chunk, data_ptr, 8);

        SHA3_1003_TIP1_mWriteReg(base_addr, REG_DIN_HIGH_OFFSET, (u32)(chunk >> 32));
        SHA3_1003_TIP1_mWriteReg(base_addr, REG_DIN_LOW_OFFSET,  (u32)(chunk & 0xFFFFFFFF));

        // Pulse din_valid for a standard 8-byte block
        u32 control2_val = (8 << 1); // Not last, 8 bytes
        SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL2_OFFSET, control2_val | CONTROL2_DIN_VALID_BIT);
        SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL2_OFFSET, control2_val);

        data_ptr += 8;
        remaining_len -= 8;
    }

    /* --- Step 3 & 4 (for the final block): Write the last data block --- */
    u64 last_chunk = 0;
    if (remaining_len > 0) {
        memcpy(&last_chunk, data_ptr, remaining_len);
    }
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_DIN_HIGH_OFFSET, (u32)(last_chunk >> 32));
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_DIN_LOW_OFFSET,  (u32)(last_chunk & 0xFFFFFFFF));

    // Pulse din_valid with the `last_din` flag and correct length
    u32 control2_final_data = CONTROL2_LAST_DIN_BIT | ((u32)remaining_len << 1);
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL2_OFFSET, control2_final_data | CONTROL2_DIN_VALID_BIT);
    // Per your logic, we don't clear din_valid immediately, the next write will do it.

    /* --- Step 5: Signal that all input is complete by setting dout_ready --- */
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL2_OFFSET, CONTROL2_DOUT_READY_BIT);

    /* --- Step 6: Wait for the result_ready flag --- */
    timeout = 1000000;
    while (((SHA3_1003_TIP1_mReadReg(base_addr, REG_STATUS_OFFSET) & STATUS_RESULT_READY_BIT) == 0) && (timeout > 0)) {
        timeout--;
    }
    if (timeout <= 0) {
        xil_printf("[ERROR] Timeout waiting for hardware result in shake256_hw!\r\n");
        // To prevent using garbage data, fill output with a recognizable pattern
        memset(out, 0xEE, outlen);
        return;
    }

    /* --- Step 7 & 8: Read and reorder the raw results --- */
    u32 result_regs[RESULT_REG_COUNT];
    for (int i = 0; i < RESULT_REG_COUNT; i++) {
        result_regs[i] = SHA3_1003_TIP1_mReadReg(base_addr, REG_RESULT_START_OFFSET + i * 4);
    }

    unsigned char reordered_buffer[sizeof(result_regs)];
    reorder_and_swap_bytes(reordered_buffer, result_regs, sizeof(reordered_buffer));

    memcpy(out, reordered_buffer, outlen);
}

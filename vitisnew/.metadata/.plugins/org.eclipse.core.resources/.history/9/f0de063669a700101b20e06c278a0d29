/*
 * main.c (Final Version: Enhanced Logging & Corrected Timing)
 */
#include <stdio.h>
#include <string.h>
#include "xil_printf.h"
#include "xstatus.h"
#include "xtime_l.h"         // Zynq timing library
#include "xparameters.h"     // Contains processor clock frequency macros
#include "xil_cache.h"       // Cache control functions

#include "api.h"
#include "fips202.h"
#include "randombytes.h"

#define MLEN 32 // Message length

// --- Function Prototypes ---
void print_hex(const char *label, const unsigned char *data, size_t len);
void init_platform();
void cleanup_platform();


int main()
{
    init_platform();
    xil_printf("\r\n--- SPHINCS+ SW/HW Full-Flow Verification & Benchmarking ---\r\n");

    int final_status = XST_SUCCESS;
    XTime t_start, t_end;
    u64 sw_sign_ticks, sw_verify_ticks, hw_sign_ticks, hw_verify_ticks;

    static unsigned char pk[CRYPTO_PUBLICKEYBYTES];
    static unsigned char sk[CRYPTO_SECRETKEYBYTES];
    static unsigned char m[MLEN];
    static unsigned char sm[CRYPTO_BYTES + MLEN];
    static unsigned char mout[CRYPTO_BYTES + MLEN];
    unsigned long long smlen, mlen_out;

    // Generate a single random message for all tests
    randombytes(m, MLEN);
    xil_printf("A %d-byte random message has been generated for all tests.\r\n", MLEN);
    print_hex("  Message (m)", m, MLEN);

    // ===================================================================
    //  Flow 1: Pure Software Baseline (SW -> SW)
    // ===================================================================
    xil_printf("\r\n--- Flow 1: Pure Software Signing and Verification (Baseline) ---\r\n");
    use_sw_shake_for_sphincs(); // **Switch to SW**

    // Time the signing process
    XTime_GetTime(&t_start);
    if (crypto_sign_keypair(pk, sk) != 0 || crypto_sign(sm, &smlen, m, MLEN, sk) != 0) {
        xil_printf("  [FAIL] SW signing process failed.\r\n");
        cleanup_platform();
        return XST_FAILURE;
    }
    XTime_GetTime(&t_end);
    sw_sign_ticks = t_end - t_start;
    xil_printf("  [INFO] SW Signing (incl. keygen) took: %llu clock cycles.\r\n", sw_sign_ticks);
    print_hex("    -> Generated PK (first 16 bytes)", pk, 16);
    print_hex("    -> Generated Signature (first 32 bytes)", sm, 32);

    // Time the verification process
    XTime_GetTime(&t_start);
    int sw_verify_result = crypto_sign_open(mout, &mlen_out, sm, smlen, pk);
    XTime_GetTime(&t_end);
    sw_verify_ticks = t_end - t_start;
    xil_printf("  [INFO] SW Verification took: %llu clock cycles.\r\n", sw_verify_ticks);

    if (sw_verify_result != 0) {
        xil_printf("  [FAIL] SW verification function returned an error!\r\n");
        final_status = XST_FAILURE;
    } else if (mlen_out != MLEN || memcmp(m, mout, MLEN) != 0) {
        xil_printf("  [FAIL] SW recovered message does not match original!\r\n");
        final_status = XST_FAILURE;
    } else {
        xil_printf("  [SUCCESS] SW signing and verification are internally consistent.\r\n");
    }


    // ===================================================================
    //  Flow 2: Pure Hardware Accelerated Test (HW -> HW)
    // ===================================================================
    xil_printf("\r\n--- Flow 2: Pure Hardware-Accelerated Signing and Verification ---\r\n");
    use_hw_shake_for_sphincs(); // **Switch to HW**

    // Time the signing process
    XTime_GetTime(&t_start);
    if (crypto_sign_keypair(pk, sk) != 0 || crypto_sign(sm, &smlen, m, MLEN, sk) != 0) {
        xil_printf("  [FAIL] HW signing process failed.\r\n");
        cleanup_platform();
        return XST_FAILURE;
    }
    XTime_GetTime(&t_end);
    hw_sign_ticks = t_end - t_start;
    xil_printf("  [INFO] HW Signing (incl. keygen) took: %llu clock cycles.\r\n", hw_sign_ticks);
    print_hex("    -> Generated PK (first 16 bytes)", pk, 16);
    print_hex("    -> Generated Signature (first 32 bytes)", sm, 32);

    // Time the verification process
    XTime_GetTime(&t_start);
    int hw_verify_result = crypto_sign_open(mout, &mlen_out, sm, smlen, pk);
    XTime_GetTime(&t_end);
    hw_verify_ticks = t_end - t_start;
    xil_printf("  [INFO] HW Verification took: %llu clock cycles.\r\n", hw_verify_ticks);

    if (hw_verify_result != 0) {
        xil_printf("  [FAIL] HW verification function returned an error!\r\n");
        final_status = XST_FAILURE;
    } else if (mlen_out != MLEN || memcmp(m, mout, MLEN) != 0) {
        xil_printf("  [FAIL] HW recovered message does not match original!\r\n");
        final_status = XST_FAILURE;
    } else {
        xil_printf("  [SUCCESS] HW signing and verification are internally consistent.\r\n");
    }

    // ===================================================================
    //  Flow 3 & 4: Cross-Verification for Compatibility
    // ===================================================================
    xil_printf("\r\n--- Flow 3 & 4: Cross-Verification for Compatibility ---\r\n");
    // SW -> HW
    use_sw_shake_for_sphincs();
    crypto_sign(sm, &smlen, m, MLEN, sk); // Use the last generated SW key
    use_hw_shake_for_sphincs();
    if (crypto_sign_open(mout, &mlen_out, sm, smlen, pk) != 0) {
        xil_printf("  [FAIL] Cross-Verification (SW Sign -> HW Verify) FAILED!\r\n");
        final_status = XST_FAILURE;
    } else {
        xil_printf("  [SUCCESS] Cross-Verification (SW Sign -> HW Verify) PASSED.\r\n");
    }
    // HW -> SW
    use_hw_shake_for_sphincs();
    crypto_sign(sm, &smlen, m, MLEN, sk); // Use the last generated HW key
    use_sw_shake_for_sphincs();
    if (crypto_sign_open(mout, &mlen_out, sm, smlen, pk) != 0) {
        xil_printf("  [FAIL] Cross-Verification (HW Sign -> SW Verify) FAILED!\r\n");
        final_status = XST_FAILURE;
    } else {
        xil_printf("  [SUCCESS] Cross-Verification (HW Sign -> SW Verify) PASSED.\r\n");
    }


    // ===================================================================
    //  Final Performance Report
    // ===================================================================
    xil_printf("\r\n\n--- Final Performance Report ---\r\n");
    xil_printf(" - SW Signing:     %llu cycles\r\n", sw_sign_ticks);
    xil_printf(" - HW Signing:     %llu cycles\r\n", hw_sign_ticks);
    xil_printf(" - SW Verification:  %llu cycles\r\n", sw_verify_ticks);
    xil_printf(" - HW Verification:  %llu cycles\r\n", hw_verify_ticks);

    // Calculate and print speed-up
    if (hw_sign_ticks > 0) {
        float sign_speedup = (float)sw_sign_ticks / hw_sign_ticks;
        printf("  => Signing Performance Speed-up: %.2f X\r\n", sign_speedup);
    }
    if (hw_verify_ticks > 0) {
        float verify_speedup = (float)sw_verify_ticks / hw_verify_ticks;
        printf("  => Verification Performance Speed-up: %.2f X\r\n", verify_speedup);
    }

    // Also print time in milliseconds
    #if defined(XPAR_CPU_CORTEXA9_0_CPU_CLK_FREQ_HZ)
        const double CPU_FREQ_MHZ = (double)XPAR_CPU_CORTEXA9_0_CPU_CLK_FREQ_HZ / 1000000.0;
    #elif defined(XPAR_PSU_CORTEXA53_0_CPU_CLK_FREQ_HZ)
        const double CPU_FREQ_MHZ = (double)XPAR_PSU_CortexA53_0_CPU_CLK_FREQ_HZ / 1000000.0;
    #else
        const double CPU_FREQ_MHZ = 0.0; // Define a default if not found
    #endif

    if (CPU_FREQ_MHZ > 0) {
        xil_printf("\r\n--- Time in Milliseconds (assuming %.0f MHz CPU clock) ---\r\n", CPU_FREQ_MHZ);
        printf(" - SW Signing:     %.2f ms\r\n", (double)sw_sign_ticks / (CPU_FREQ_MHZ * 1000.0));
        printf(" - HW Signing:     %.2f ms\r\n", (double)hw_sign_ticks / (CPU_FREQ_MHZ * 1000.0));
        printf(" - SW Verification:  %.2f ms\r\n", (double)sw_verify_ticks / (CPU_FREQ_MHZ * 1000.0));
        printf(" - HW Verification:  %.2f ms\r\n", (double)hw_verify_ticks / (CPU_FREQ_MHZ * 1000.0));
    }


    if (final_status == XST_SUCCESS) {
        xil_printf("\r\n[FINAL CONCLUSION: ALL PASSED] Functionality is correct and performance data has been collected.\r\n");
    } else {
        xil_printf("\r\n[FINAL CONCLUSION: FAILED] A functional verification step failed. Performance data may be invalid.\r\n");
    }

    cleanup_platform();
    return final_status;
}


/******************************************************************************
*
* Helper Function Implementations
*
******************************************************************************/

/**
 * @brief Prints data in hexadecimal format.
 */
void print_hex(const char *label, const unsigned char *data, size_t len) {
    xil_printf("%s: ", label);
    for (size_t i = 0; i < len; i++) {
        xil_printf("%02x", data[i]);
    }
    xil_printf("\r\n");
}

/**
 * @brief Initializes the platform (e.g., enables caches).
 */
void init_platform()
{
    /* Enable the instruction cache */
    Xil_ICacheEnable();

    /* Enable the data cache */
    Xil_DCacheEnable();

    xil_printf("Platform initialized (Caches Enabled)\r\n");
}

/**
 * @brief Cleans up the platform (e.g., disables caches).
 */
void cleanup_platform()
{
    /* Disable the data cache */
    Xil_DCacheDisable();

    /* Disable the instruction cache */
    Xil_ICacheDisable();

    xil_printf("Platform cleaned up (Caches Disabled)\r\n");
}

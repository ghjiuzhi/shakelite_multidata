#include "fpga_sha_driver.h"
#include "sha3_1003_tIP1.h" // 包含底层硬件驱动宏
#include "xil_printf.h"
#include "xil_io.h"

// send_data_block_to_fpga 是一个内部辅助函数，所以我们不需要在.h中声明它
// 把它定义为 static 是一个好习惯，表示它只在本文件内使用
static void send_data_block_to_fpga(u32 base_addr, const unsigned char *data_ptr, u32 len, int is_last_block)
{
    if (len == 0 || len > 8) return;

    u64 write_data = 0;
    for (u32 i = 0; i < len; i++) {
        write_data |= (u64)data_ptr[i] << (56 - (i * 8));
    }

    u32 high_32 = (u32)(write_data >> 32);
    u32 low_32  = (u32)(write_data & 0xFFFFFFFF);
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_DIN_HIGH_OFFSET, high_32);
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_DIN_LOW_OFFSET, low_32);

    u32 control2_val = (len << 1);
    if (is_last_block) {
        control2_val |= CONTROL2_LAST_DIN_BIT;
    }

    SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL2_OFFSET, control2_val | CONTROL2_DIN_VALID_BIT);
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL2_OFFSET, control2_val);
}

// 这里是 thash_shake_fpga 函数的完整实现
void thash_shake_fpga(unsigned char *out, const unsigned char *in,
                      unsigned long long inlen, const spx_ctx *ctx,
                      uint32_t addr[8])
{
    u32 base_addr = IP_CORE_BASEADDR;

    xil_printf("--- Executing Hardware Accelerated thash_shake_fpga ---\r\n");

    u32 control_val = 1; // Mode 1: Shake-256
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL_OFFSET, control_val);
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL_OFFSET, control_val | CONTROL_START_BIT);
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL_OFFSET, control_val);

    const unsigned char *pub_seed = ctx->pub_seed;
    const unsigned char *address = (const unsigned char *)addr;
    const unsigned char *message = in;

    unsigned long long total_len = SPX_N + 32 + inlen;
    unsigned long long bytes_sent = 0;

    xil_printf("  Total data to send: %llu bytes\r\n", total_len);

    while (bytes_sent < total_len) {
        unsigned char buffer[8];
        int is_last = 0;
        u32 chunk_size = (total_len - bytes_sent > 8) ? 8 : (total_len - bytes_sent);

        for (u32 i = 0; i < chunk_size; i++) {
            unsigned long long current_pos = bytes_sent + i;
            if (current_pos < SPX_N) {
                buffer[i] = pub_seed[current_pos];
            } else if (current_pos < SPX_N + 32) {
                buffer[i] = address[current_pos - SPX_N];
            } else {
                buffer[i] = message[current_pos - SPX_N - 32];
            }
        }

        if (bytes_sent + chunk_size == total_len) {
            is_last = 1;
        }

        send_data_block_to_fpga(base_addr, buffer, chunk_size, is_last);
        bytes_sent += chunk_size;
    }

    xil_printf("  All data blocks sent to FPGA.\r\n");

    SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL2_OFFSET, CONTROL2_DOUT_READY_BIT);

    u32 status_reg;
    int timeout = 2000000;
    xil_printf("  Waiting for FPGA to complete...\r\n");
    do {
        status_reg = SHA3_1003_TIP1_mReadReg(base_addr, REG_STATUS_OFFSET);
        timeout--;
    } while (((status_reg & STATUS_RESULT_READY_BIT) == 0) && (timeout > 0));

    if (timeout <= 0) {
        xil_printf("  [FATAL ERROR] Timeout waiting for FPGA result!\r\n");
        return;
    }
    xil_printf("  FPGA calculation complete!\r\n");

    u32 result_buffer[RESULT_REG_COUNT];
    for (int i = 0; i < RESULT_REG_COUNT; i++) {
        result_buffer[i] = SHA3_1003_TIP1_mReadReg(base_addr, REG_RESULT_START_OFFSET + i * 4);
    }

    for (int i = 0; i < (SPX_N / 4); i++) {
        out[i*4 + 0] = (unsigned char)(result_buffer[i] >> 24);
        out[i*4 + 1] = (unsigned char)(result_buffer[i] >> 16);
        out[i*4 + 2] = (unsigned char)(result_buffer[i] >> 8);
        out[i*4 + 3] = (unsigned char)(result_buffer[i] >> 0);
    }
}

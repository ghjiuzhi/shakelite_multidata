#include <stdio.h>
#include <string.h>
#include "xil_printf.h"
#include "xil_types.h"
#include "xstatus.h"
#include "xil_cache.h"
#include "xtime_l.h"

// 包含所有必需的 SPHINCS+ 和 SHAKE 头文件
#include "api.h"
#include "params.h"
#include "fips202.h" // <-- 包含纯软件 SHAKE 实现的头文件

#define MESSAGE_LEN 32

/************************** 函数原型 ***************************/
void print_hex(const char *label, const unsigned char *data, size_t len);
int run_shake256_comparison_test(); // <-- 新增的对比测试函数
int run_sphincs_test_forensic();
void init_platform();
void cleanup_platform();

/* 声明外部硬件驱动函数 */
extern void shake256_hw(uint8_t *out, size_t outlen, const uint8_t *in, const size_t inlen);


/*****************************************************************************/
int main()
{
    int status;
    init_platform();

    // --- 终极验证：直接对比软硬件哈希函数 ---
    xil_printf("\r\n\n--- SHAKE256 软硬件实现对比测试 ---\r\n");
    status = run_shake256_comparison_test();
    if (status != XST_SUCCESS) {
        xil_printf("\r\n[对比失败] 硬件 SHAKE256 实现与软件不一致！测试终止。\r\n");
        cleanup_platform();
        return XST_FAILURE;
    }
    xil_printf("[对比成功] 硬件 SHAKE256 实现与软件完全一致！\r\n");


    // --- 完整的 SPHINCS+ 应用测试 ---
    xil_printf("\r\n\n--- SPHINCS+ 最终版法证调试测试 ---\r\n");
    status = run_sphincs_test_forensic();

    if (status == XST_SUCCESS) {
        xil_printf("\r\n[测试通过] 所有步骤均已成功完成和验证！硬件加速功能正确！\r\n");
    } else {
        xil_printf("\r\n[执行失败] SPHINCS+ 测试在上述某个步骤中失败。\r\n");
    }

    cleanup_platform();
    return status;
}

/*****************************************************************************/
/**
* @brief 对比硬件和软件 SHAKE256 实现的输出，作为“黄金标准”测试。
*/
int run_shake256_comparison_test()
{
    // 准备几组不同的测试输入
    unsigned char input1[3] = "abc";
    unsigned char input2[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    unsigned char input3[64];
    for(int i=0; i<64; i++) { input3[i] = i; }

    unsigned char hw_output[64];
    unsigned char sw_output[64];
    int status = XST_SUCCESS;

    // --- 测试用例 1: "abc" ---
    xil_printf("\r\n--- 测试用例 1: 输入 'abc' (3字节) ---\r\n");
    shake256_hw(hw_output, 32, input1, 3); // 硬件计算
    shake256(sw_output, 32, input1, 3);    // 软件计算 (来自 fips202.c)

    print_hex("  硬件输出", hw_output, 32);
    print_hex("  软件输出", sw_output, 32);

    if (memcmp(hw_output, sw_output, 32) != 0) {
        xil_printf("  [错误] 测试用例 1 输出不匹配！\r\n");
        status = XST_FAILURE;
    } else {
        xil_printf("  [成功] 测试用例 1 输出匹配。\r\n");
    }

    // --- 测试用例 2: 10字节的二进制数据 ---
    xil_printf("\r\n--- 测试用例 2: 输入 10字节 二进制数据 ---\r\n");
    shake256_hw(hw_output, 32, input2, 10);
    shake256(sw_output, 32, input2, 10);

    print_hex("  硬件输出", hw_output, 32);
    print_hex("  软件输出", sw_output, 32);

    if (memcmp(hw_output, sw_output, 32) != 0) {
        xil_printf("  [错误] 测试用例 2 输出不匹配！\r\n");
        status = XST_FAILURE;
    } else {
        xil_printf("  [成功] 测试用例 2 输出匹配。\r\n");
    }

    // --- 测试用例 3: 64字节的二进制数据 ---
    xil_printf("\r\n--- 测试用例 3: 输入 64字节 二进制数据 ---\r\n");
    shake256_hw(hw_output, 64, input3, 64);
    shake256(sw_output, 64, input3, 64);

    print_hex("  硬件输出 (前32字节)", hw_output, 32);
    print_hex("  软件输出 (前32字节)", sw_output, 32);

    if (memcmp(hw_output, sw_output, 64) != 0) {
        xil_printf("  [错误] 测试用例 3 输出不匹配！\r\n");
        status = XST_FAILURE;
    } else {
        xil_printf("  [成功] 测试用例 3 输出匹配。\r\n");
    }

    return status;
}


/*****************************************************************************/
int run_sphincs_test_forensic()
{
    // ... (这个函数保持不变) ...
    static unsigned char pk[CRYPTO_PUBLICKEYBYTES];
    static unsigned char sk[CRYPTO_SECRETKEYBYTES];
    static unsigned char m[MESSAGE_LEN];
    static unsigned char sm[CRYPTO_BYTES + MESSAGE_LEN];
    static unsigned char mout[CRYPTO_BYTES + MESSAGE_LEN];

    unsigned long long smlen;
    unsigned long long mlen_out;
    int ret_val;

    xil_printf("--- 步骤 1: 准备一个 %d 字节的消息 ---\r\n", MESSAGE_LEN);
    for (int i = 0; i < MESSAGE_LEN; i++) { m[i] = (unsigned char)i; }
    print_hex("  原始消息 (m)", m, MESSAGE_LEN);

    xil_printf("\r\n--- 步骤 2: 生成密钥对 ---\r\n");
    if (crypto_sign_keypair(pk, sk) != 0) {
        xil_printf("  [错误] 密钥对生成失败！\r\n");
        return XST_FAILURE;
    }
    xil_printf("  密钥对生成成功。\r\n");
    print_hex("  公钥 (pk) (前 32 字节)", pk, 32);

    xil_printf("\r\n--- 步骤 3: 对消息进行签名 ---\r\n");
    ret_val = crypto_sign(sm, &smlen, m, MESSAGE_LEN, sk);

    if (ret_val != 0) {
        xil_printf("  [错误] crypto_sign 函数返回了一个错误码: %d！\r\n", ret_val);
        return XST_FAILURE;
    }
    xil_printf("  crypto_sign 函数执行完毕。\r\n");
    xil_printf("  报告的总签名消息长度 (smlen): %d 字节。\r\n", (int)smlen);

    const int expected_smlen = CRYPTO_BYTES + MESSAGE_LEN;
    const int actual_smlen = (int)smlen;

    xil_printf("\r\n--- 步骤 3.1: 签名长度法证检查 (使用32位整数比较) ---\r\n");
    if (actual_smlen != expected_smlen) {
        xil_printf("\r\n  [!!! 关键失败 !!!] 签名长度不正确！\r\n");
        return XST_FAILURE;
    } else {
        xil_printf("  [判断通过] 签名长度正确。\r\n");
    }
    print_hex("  签名消息 (sm) (前 32 字节)", sm, 32);

    xil_printf("\r\n--- 步骤 4: 验证签名 ---\r\n");
    ret_val = crypto_sign_open(mout, &mlen_out, sm, smlen, pk);

    if (ret_val != 0) {
        xil_printf("  [错误] 验证函数返回错误码 %d！签名无效。\r\n", ret_val);
        return XST_FAILURE;
    }
    xil_printf("  签名验证函数成功返回 (返回码: %d)。\r\n", ret_val);
    xil_printf("  恢复出的消息长度 (mlen_out): %d 字节。\r\n", (int)mlen_out);
    print_hex("  恢复的消息 (mout)", mout, (int)mlen_out);

    xil_printf("\r\n--- 步骤 5: 最终内容检查 ---\r\n");
    if ((int)mlen_out != MESSAGE_LEN || memcmp(m, mout, MESSAGE_LEN) != 0) {
        xil_printf("  [错误] 消息内容不匹配！\r\n");
        return XST_FAILURE;
    }
    xil_printf("  原始消息和恢复的消息完全匹配。\r\n");

    return XST_SUCCESS;
}


/************************** 辅助函数 ***************************/

void print_hex(const char *label, const unsigned char *data, size_t len) {
    xil_printf("%s: ", label);
    for (size_t i = 0; i < len; i++) {
        xil_printf("%02x", data[i]);
    }
    xil_printf("\r\n");
}

void init_platform() {
    Xil_ICacheEnable();
    Xil_DCacheEnable();
}

void cleanup_platform() {
    Xil_DCacheDisable();
    Xil_ICacheDisable();
}

#include <stdio.h>
#include <string.h>
#include "xil_printf.h"
#include "xil_types.h"
#include "xstatus.h"
#include "xil_cache.h"
#include "xtime_l.h"

//版本：(恢复消息匹配，验证完成）.bak
// 包含所有必需的 SPHINCS+ 头文件
#include "api.h"
#include "params.h"

// 编译时健全性检查
#if !defined(CRYPTO_BYTES)
    #error "SPHINCS+ parameters not loaded correctly. Please check params.h and your build settings."
#endif

#define MESSAGE_LEN 32

/************************** 函数原型 ***************************/
void print_hex(const char *label, const unsigned char *data, size_t len);
int run_sphincs_test_forensic();
void init_platform();
void cleanup_platform();

/*
 * ============================================================================
 * 开始修改
 * ============================================================================
 */

/* 1. 将原始的外部硬件驱动函数声明重命名，以便我们的包装函数可以使用原始名称。*/
extern void shake256_hw_real(uint8_t *out, size_t outlen, const uint8_t *in, const size_t inlen);

/**
 * @brief shake256_hw 硬件函数的包装器，用于测量两次调用之间的时钟周期。
 *
 * 这个函数会“拦截”对硬件SHAKE256加速器的所有调用。它使用高精度定时器(XTime)
 * 来测量并打印从上一次调用开始到本次调用开始所经过的时钟周期数（ticks）。
 * 这样我们就能在不修改SPHINCS+库代码的情况下，分析算法内部的哈希操作时序。
 *
 * @param out 指向哈希输出缓冲区的指针。
 * @param outlen 期望的输出长度（字节）。
 * @param in 指向要进行哈希计算的输入数据的指针。
 * @param inlen 输入数据的长度（字节）。
 */
void shake256_hw(uint8_t *out, size_t outlen, const uint8_t *in, const size_t inlen)
{
    // 使用静态变量存储上一次调用的时间戳。
    // 它被初始化为0，并且能在多次函数调用之间保持其值。
    static XTime last_time = 0;
    XTime current_time;

    // 从高精度定时器获取当前时间。这个值的单位是时钟周期(ticks)。
    XTime_GetTime(&current_time);

    // 如果这不是第一次调用（last_time不为0），则计算并打印时间间隔。
    if (last_time != 0) {
        // 计算时钟周期的差值。这个值就是从上一次调用shake256_hw开始
        // 到本次调用shake256_hw开始所经过的处理器时钟周期数。
        XTime interval_ticks = current_time - last_time;

        // 打印间隔的时钟周期数。'%llu'用于打印64位的无符号长整型(XTime)。
        xil_printf("[TIMER] 两次shake256_hw调用间隔: %llu 个时钟周期 (ticks)\r\n", interval_ticks);
    }

    // 更新 last_time 为当前时间，为下一次间隔测量做准备。
    last_time = current_time;

    // 调用我们重命名后的“真正”的硬件函数来执行哈希计算。
    shake256_hw_real(out, outlen, in, inlen);
}

/*
 * ============================================================================
 * 结束修改
 * ============================================================================
 */


/*****************************************************************************/
int main()
{
    int status;
    init_platform();

    xil_printf("\r\n\n--- SPHINCS+ 最终版法证调试测试 ---\r\n");
    xil_printf("本测试将打印并比较真实的32位整数长度值，消除显示错误。\r\n");
    xil_printf("SPHINCS+ 参数集: %s\r\n", xstr(PARAMS));
    xil_printf("期望签名长度 (CRYPTO_BYTES): %d\r\n\n", CRYPTO_BYTES);

    status = run_sphincs_test_forensic();

    if (status == XST_SUCCESS) {
        xil_printf("\r\n[测试通过] 所有步骤均已成功完成和验证！硬件加速功能正确！\r\n");
    } else {
        xil_printf("\r\n[执行失败] 测试在上述某个步骤中失败。\r\n");
    }

    cleanup_platform();
    return status;
}

/*****************************************************************************/
int run_sphincs_test_forensic()
{
    static unsigned char pk[CRYPTO_PUBLICKEYBYTES];
    static unsigned char sk[CRYPTO_SECRETKEYBYTES];
    static unsigned char m[MESSAGE_LEN];
    static unsigned char sm[CRYPTO_BYTES + MESSAGE_LEN];
    static unsigned char mout[CRYPTO_BYTES + MESSAGE_LEN];

    unsigned long long smlen; // API要求使用 unsigned long long, 我们保留它
    unsigned long long mlen_out;
    int ret_val;
    XTime t_start, t_end;

    xil_printf("--- 步骤 1: 准备一个 %d 字节的消息 ---\r\n", MESSAGE_LEN);
    for (int i = 0; i < MESSAGE_LEN; i++) { m[i] = (unsigned char)i; }
    print_hex("  原始消息 (m)", m, MESSAGE_LEN);

    xil_printf("\r\n--- 步骤 2: 生成密钥对 ---\r\n");
    if (crypto_sign_keypair(pk, sk) != 0) {
        xil_printf("  [错误] 密钥对生成失败！\r\n");
        return XST_FAILURE;
    }
    xil_printf("  密钥对生成成功。\r\n");
    print_hex("  公钥 (pk) (前 32 字节)", pk, 32);

    xil_printf("\r\n--- 步骤 3: 对消息进行签名 ---\r\n");
    ret_val = crypto_sign(sm, &smlen, m, MESSAGE_LEN, sk);

    if (ret_val != 0) {
        xil_printf("  [错误] crypto_sign 函数返回了一个错误码: %d！\r\n", ret_val);
        return XST_FAILURE;
    }
    xil_printf("  crypto_sign 函数执行完毕。\r\n");

    // **关键修改**：使用(int)进行打印，以获取真实值
    xil_printf("  报告的总签名消息长度 (smlen): %d 字节。\r\n", (int)smlen);

    // --- 决定性的签名长度检查 (使用int强制转换) ---
    const int expected_smlen = CRYPTO_BYTES + MESSAGE_LEN;
    const int actual_smlen = (int)smlen;

    xil_printf("\r\n--- 步骤 3.1: 签名长度法证检查 (使用32位整数比较) ---\r\n");
    xil_printf("  即将对以下【真实】数值进行比较:\r\n");
    xil_printf("    - 期望签名长度 (expected_smlen): %d\r\n", expected_smlen);
    xil_printf("    - 实际签名长度 (actual_smlen)   : %d\r\n", actual_smlen);

    if (actual_smlen != expected_smlen) {
        xil_printf("\r\n  [!!! 关键失败 !!!] 签名长度不正确！\r\n");
        xil_printf("    -> 判断语句 if (%d != %d) 的结果为真。\r\n", actual_smlen, expected_smlen);
        return XST_FAILURE;
    } else {
        xil_printf("\r\n  [判断通过] 签名长度正确。\r\n");
        xil_printf("    -> 判断语句 if (%d != %d) 的结果为假。\r\n", actual_smlen, expected_smlen);
    }
    print_hex("  签名消息 (sm) (前 32 字节)", sm, 32);

    xil_printf("\r\n--- 步骤 4: 验证签名 ---\r\n");
    ret_val = crypto_sign_open(mout, &mlen_out, sm, smlen, pk);

    if (ret_val != 0) {
        xil_printf("  [错误] 验证函数返回错误码 %d！签名无效。\r\n", ret_val);
        return XST_FAILURE;
    }
    xil_printf("  签名验证函数成功返回 (返回码: %d)。\r\n", ret_val);
    xil_printf("  恢复出的消息长度 (mlen_out): %d 字节。\r\n", (int)mlen_out);

    // **新增的显式证据**
    print_hex("  恢复的消息 (mout)", mout, (int)mlen_out);

    xil_printf("\r\n--- 步骤 5: 最终内容检查 ---\r\n");
    xil_printf("  比对内容: 原始消息 (m) vs 恢复的消息 (mout)\r\n");
    if ((int)mlen_out != MESSAGE_LEN || memcmp(m, mout, MESSAGE_LEN) != 0) {
        xil_printf("  [错误] 消息内容不匹配！\r\n");
        return XST_FAILURE;
    }
    xil_printf("  原始消息和恢复的消息完全匹配。\r\n");

    return XST_SUCCESS;
}

/************************** 辅助函数 ***************************/
void print_hex(const char *label, const unsigned char *data, size_t len) {
    xil_printf("%s: ", label);
    for (size_t i = 0; i < len; i++) {
        xil_printf("%02x", data[i]);
    }
    xil_printf("\r\n");
}

void init_platform() {
    Xil_DCacheDisable();
    Xil_ICacheEnable();
    Xil_DCacheEnable();
}

void cleanup_platform() {
    Xil_DCacheDisable();
    Xil_ICacheDisable();
}

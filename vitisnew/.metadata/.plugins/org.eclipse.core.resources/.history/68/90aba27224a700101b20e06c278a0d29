#include <stdio.h>
#include <string.h>
#include "xil_printf.h"
#include "xil_types.h"
#include "xstatus.h"
#include "xil_cache.h"
#include "xtime_l.h"

// 包含所有必需的 SPHINCS+ 头文件
#include "api.h"
#include "params.h"
#include "wots.h"
#include "fors.h"
#include "utils.h"

// 编译时健全性检查：
// 如果 SPHINCS+ 参数没有从 params.h 正确加载，
// CRYPTO_BYTES 将不会被定义。这将导致编译错误。
#if !defined(CRYPTO_BYTES)
    #error "SPHINCS+ parameters not loaded correctly. Please check params.h and your build settings."
#endif

#define MESSAGE_LEN 32

/************************** 函数原型 ***************************/
void print_hex(const char *label, const unsigned char *data, size_t len);
int run_sphincs_test_forensic();
void init_platform();
void cleanup_platform();

/* 声明外部硬件驱动函数，以便 main.c 能够调用它 */
extern void shake256_hw(uint8_t *out, size_t outlen, const uint8_t *in, const size_t inlen);


/*****************************************************************************/
int main()
{
    int status;
    init_platform();

    xil_printf("\r\n\n--- SPHINCS+ 故障定位调试测试 ---\r\n");
    xil_printf("本测试将打印详细步骤以定位故障点。\r\n");
    xil_printf("SPHINCS+ 参数集: %s\r\n", xstr(PARAMS));
    xil_printf("期望签名长度 (CRYPTO_BYTES): %d\r\n\n", CRYPTO_BYTES);

    status = run_sphincs_test_forensic();

    if (status == XST_SUCCESS) {
        xil_printf("\r\n[测试通过] 所有步骤均已成功完成和验证！\r\n");
    } else {
        xil_printf("\r\n[执行失败] 测试在上述某个步骤中失败。\r\n");
    }

    cleanup_platform();
    return status;
}

/*****************************************************************************/
int run_sphincs_test_forensic()
{
    static unsigned char pk[CRYPTO_PUBLICKEYBYTES];
    static unsigned char sk[CRYPTO_SECRETKEYBYTES];
    static unsigned char m[MESSAGE_LEN];
    static unsigned char sm[CRYPTO_BYTES + MESSAGE_LEN];
    static unsigned char mout[CRYPTO_BYTES + MESSAGE_LEN];

    unsigned long long smlen;
    unsigned long long mlen_out;
    int ret_val;
    XTime t_start, t_end;

    xil_printf("--- 步骤 1: 准备一个 %d 字节的消息 ---\r\n", MESSAGE_LEN);
    for (int i = 0; i < MESSAGE_LEN; i++) { m[i] = (unsigned char)i; }
    print_hex("  原始消息", m, MESSAGE_LEN);

    xil_printf("\r\n--- 步骤 2: 生成密钥对 (公钥: %d 字节, 私钥: %d 字节) ---\r\n", CRYPTO_PUBLICKEYBYTES, CRYPTO_SECRETKEYBYTES);
    XTime_GetTime(&t_start);
    if (crypto_sign_keypair(pk, sk) != 0) {
        xil_printf("  [错误] 密钥对生成失败！\r\n");
        return XST_FAILURE;
    }
    XTime_GetTime(&t_end);
    xil_printf("  密钥对生成成功，用时 %llu 个时钟周期。\r\n", (unsigned long long)(t_end - t_start));
    print_hex("  公钥 (前 32 字节)", pk, 32);

    xil_printf("\r\n--- 步骤 3: 对消息进行签名 ---\r\n");
    xil_printf("  签名过程涉及大量哈希调用。我们将追踪主要步骤。\r\n");
    XTime_GetTime(&t_start);

    // 调用核心签名函数
    ret_val = crypto_sign(sm, &smlen, m, MESSAGE_LEN, sk);

    if (ret_val != 0) {
        xil_printf("  [错误] crypto_sign 函数返回了一个错误码: %d！\r\n", ret_val);
        return XST_FAILURE;
    }
    XTime_GetTime(&t_end);
    xil_printf("  crypto_sign 函数执行完毕，用时 %llu 个时钟周期。\r\n", (unsigned long long)(t_end - t_start));
    xil_printf("  报告的总签名消息长度: %llu 字节。\r\n", smlen);

    // --- 增强的签名长度检查 ---
    const unsigned long long expected_smlen = CRYPTO_BYTES + MESSAGE_LEN;
    xil_printf("  正在执行签名长度检查...\r\n");
    if (smlen != expected_smlen) {
        xil_printf("\r\n  [!!! 关键失败 !!!] 签名长度不正确！\r\n");
        xil_printf("    - 期望的总长度: %llu 字节\r\n", expected_smlen);
        xil_printf("    - 硬件返回的实际总长度:   %llu 字节\r\n", smlen);
        xil_printf("    - 诊断建议:\n");
        xil_printf("      1. 这几乎可以肯定是由于硬件加速器(fpga_sha_driver.c)在某个中间步骤产生了一个或多个错误的哈希值。\r\n");
        xil_printf("      2. SPHINCS+算法的内部状态因错误的哈希值而损坏，导致最终计算出的签名长度错误。\r\n");
        xil_printf("      3. 请重点检查 `fpga_sha_driver.c` 中的 `reorder_hardware_output` 函数，确保它对硬件寄存器数据的字节序和排列顺序的处理是完全正确的。\r\n");

        // **新增调试语句**: 打印完整的、错误的签名消息内容
        xil_printf("\r\n  [调试信息] 以下是硬件返回的全部 %llu 字节的原始签名数据，用于分析：\r\n", smlen);
        print_hex("    原始SM数据", sm, smlen);

        xil_printf("\r\n    测试终止。\r\n");
        return XST_FAILURE;
    }
    xil_printf("  签名长度正确。\r\n");
    print_hex("  签名部分 (前 32 字节)", sm, 32);


    xil_printf("\r\n--- 步骤 4: 验证签名 ---\r\n");
    XTime_GetTime(&t_start);
    ret_val = crypto_sign_open(mout, &mlen_out, sm, smlen, pk);
    XTime_GetTime(&t_end);

    if (ret_val != 0) {
        xil_printf("  [错误] 验证函数返回错误码 %d！签名无效。\r\n", ret_val);
        return XST_FAILURE;
    }
    xil_printf("  签名验证成功，用时 %llu 个时钟周期。\r\n", (unsigned long long)(t_end - t_start));

    xil_printf("\r\n--- 步骤 5: 最终内容检查 ---\r\n");
    if (mlen_out != MESSAGE_LEN || memcmp(m, mout, MESSAGE_LEN) != 0) {
        xil_printf("  [错误] 消息内容不匹配！原始消息和恢复的消息不同。\r\n");
        print_hex("  恢复的消息", mout, mlen_out);
        return XST_FAILURE;
    }
    xil_printf("  原始消息和恢复的消息完全匹配。\r\n");

    return XST_SUCCESS;
}


/************************** 辅助函数 ***************************/

void print_hex(const char *label, const unsigned char *data, size_t len) {
    xil_printf("%s: ", label);
    for (size_t i = 0; i < len; i++) {
        xil_printf("%02x", data[i]);
    }
    xil_printf("\r\n");
}

void init_platform() {
    Xil_DCacheDisable();
    Xil_ICacheEnable();
    Xil_DCacheEnable();
}

void cleanup_platform() {
    Xil_DCacheDisable();
    Xil_ICacheDisable();
}

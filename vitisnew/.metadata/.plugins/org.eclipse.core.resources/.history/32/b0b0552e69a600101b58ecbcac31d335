/***************************** Include Files *******************************/
#include "xparameters.h"
#include "xil_printf.h"
#include "xstatus.h"
#include "xil_cache.h"
#include "xil_io.h"
#include "sha3_1003_tIP1.h"

/************************** Constant Definitions ***************************/
#define IP_CORE_BASEADDR        XPAR_SHA3_1003_TIP1_0_S0_AXI_BASEADDR
#define REG_CONTROL_OFFSET      0x00
#define REG_DIN_LOW_OFFSET      0x04
#define REG_DIN_HIGH_OFFSET     0x08
#define REG_CONTROL2_OFFSET     0x0C
#define REG_STATUS_OFFSET       0x10
#define REG_RESULT_START_OFFSET 0x14
#define CONTROL_START_BIT       (1 << 3)
#define CONTROL2_LAST_DIN_BIT   (1 << 0)
#define CONTROL2_DIN_VALID_BIT  (1 << 5)
#define CONTROL2_DOUT_READY_BIT (1 << 6)
#define STATUS_RESULT_READY_BIT (1 << 5)
#define RESULT_REG_COUNT 42

/************************** Function Prototypes ****************************/
void init_platform();
void cleanup_platform();
int run_test(u32 base_addr, const char* test_name, u32 high, u32 low, int use_validation_timing);
void print_separator();
void print_conclusion(int test1a_res, int test1b_res, int test2a_res, int test2b_res);

/*****************************************************************************/
int main()
{
    init_platform();
    xil_printf("\r\n\n\n--- SHA3 IP Core: 终极诊断程序 ---\r\n");
    xil_printf("--- 目标: 验证 'start_i' 信号是否错误地复位了计算核心 ---\r\n");

    // =========================================================================
    // 第一轮: 使用“标准时序” (Standard Timing)
    // 猜想: 结果会相同，证明输入被忽略
    // =========================================================================
    print_separator();
    xil_printf("第一轮测试: 使用“标准时序” (之前一直失败的时序)\r\n");
    xil_printf("预期结果: 下面两个测试的哈希值应该【完全一样】\r\n");
    print_separator();

    int test1a_res = run_test(IP_CORE_BASEADDR, "测试 1-A", 0xAAAAAAAA, 0xBBBBBBBB, 0);
    int test1b_res = run_test(IP_CORE_BASEADDR, "测试 1-B", 0xCCCCCCCC, 0xDDDDDDDD, 0);

    // =========================================================================
    // 第二轮: 使用“验证时序” (Validation Timing)
    // 猜想: 结果会不同，证明输入被正确处理
    // =========================================================================
    print_separator();
    xil_printf("第二轮测试: 使用“验证时序” (短暂Start脉冲)\r\n");
    xil_printf("预期结果: 下面两个测试的哈希值应该【完全不同】\r\n");
    print_separator();

    int test2a_res = run_test(IP_CORE_BASEADDR, "测试 2-A", 0xAAAAAAAA, 0xBBBBBBBB, 1);
    int test2b_res = run_test(IP_CORE_BASEADDR, "测试 2-B", 0xCCCCCCCC, 0xDDDDDDDD, 1);

    // =========================================================================
    // 最终结论
    // =========================================================================
    print_conclusion(test1a_res, test1b_res, test2a_res, test2b_res);

    cleanup_platform();
    return 0;
}

/*****************************************************************************/
/**
* @brief    执行一次完整的SHA计算，可以选择使用标准时序或验证时序
******************************************************************************/
int run_test(u32 base_addr, const char* test_name, u32 high, u32 low, int use_validation_timing)
{
    u32 status_reg;
    u32 result_buffer[RESULT_REG_COUNT] = {0};
    int i;
    int timeout = 1000000;
    u32 control_val = 1; // 模式1: Shake-256
    u32 control2_val = CONTROL2_LAST_DIN_BIT | (8 << 1) | CONTROL2_DOUT_READY_BIT;

    xil_printf("\r\n--- %s ---\r\n", test_name);
    xil_printf("输入数据 -> 高位: 0x%08X, 低位: 0x%08X\r\n", high, low);

    // 写入数据
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_DIN_HIGH_OFFSET, high);
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_DIN_LOW_OFFSET, low);
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL2_OFFSET, control2_val);

    if (use_validation_timing) {
        // --- “验证时序” (短暂Start脉冲) ---
        xil_printf("执行方式: 验证时序 (短Start脉冲)\r\n");
        SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL_OFFSET, control_val); // 准备
        // 发送极短的start脉冲
        SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL_OFFSET, control_val | CONTROL_START_BIT);
        SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL_OFFSET, control_val);
        // 在start结束后再发送din_valid脉冲
        SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL2_OFFSET, control2_val | CONTROL2_DIN_VALID_BIT);
        SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL2_OFFSET, control2_val);

    } else {
        // --- “标准时序” (之前失败的时序) ---
        xil_printf("执行方式: 标准时序 (长Start信号)\r\n");
        SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL_OFFSET, control_val); // 准备
        // 拉高start和din_valid
        SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL_OFFSET, control_val | CONTROL_START_BIT);
        SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL2_OFFSET, control2_val | CONTROL2_DIN_VALID_BIT);
        // 拉低它们
        SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL_OFFSET, control_val);
        SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL2_OFFSET, control2_val);
    }

    // 等待计算完成
    do {
        status_reg = SHA3_1003_TIP1_mReadReg(base_addr, REG_STATUS_OFFSET);
        timeout--;
    } while (((status_reg & STATUS_RESULT_READY_BIT) == 0) && (timeout > 0));

    if (timeout <= 0) {
        xil_printf("  [错误] 等待超时! 状态寄存器: 0x%08X\r\n", status_reg);
        return -1; // 返回错误码
    }

    // 读取并打印第一个非零的结果寄存器用于快速比较
    for (i = 0; i < RESULT_REG_COUNT; i++) {
        result_buffer[i] = SHA3_1003_TIP1_mReadReg(base_addr, REG_RESULT_START_OFFSET + i * 4);
        if(result_buffer[i] != 0) {
            xil_printf("哈希结果 (reg[%d]): 0x%08X\r\n", i, result_buffer[i]);
            return result_buffer[i]; // 返回第一个非零值用于比较
        }
    }
    xil_printf("哈希结果: 全部为零\r\n");
    return 0; // 如果全零则返回0
}

/*****************************************************************************/
void print_separator()
{
    xil_printf("=====================================================================\r\n");
}

/*****************************************************************************/
void print_conclusion(int test1a_res, int test1b_res, int test2a_res, int test2b_res)
{
    print_separator();
    xil_printf("最终诊断结论:\r\n");
    print_separator();

    // 检查第一轮
    if (test1a_res == test1b_res) {
        xil_printf("[✓] 验证成功: 在“标准时序”下, 不同输入 (0xAAAA... vs 0xCCCC...) 得到了【相同】的结果。\r\n");
        xil_printf("    >> 这证明了硬件在该时序下忽略了我们的输入数据。\r\n");
    } else {
        xil_printf("[✗] 验证意外: 在“标准时序”下, 不同输入得到了【不同】的结果。这不符合我们之前的观察。\r\n");
    }

    // 检查第二轮
    if (test2a_res != test2b_res) {
        xil_printf("[✓] 验证成功: 在“验证时序”下, 不同输入 (0xAAAA... vs 0xCCCC...) 得到了【不同】的结果。\r\n");
        xil_printf("    >> 这证明了硬件在该时序下成功处理了我们的输入数据。\r\n");
    } else {
        xil_printf("[✗] 验证意外: 在“验证时序”下, 不同输入得到了【相同】的结果。这说明问题可能更复杂。\r\n");
    }

    print_separator();

    // 最终定论
    if ((test1a_res == test1b_res) && (test2a_res != test2b_res)) {
        xil_printf("【最终结论】: 猜想被证实！\r\n");
        xil_printf("问题根源在于您的Verilog代码。'start_i'信号被错误地连接到了计算核心的复位端口上。\r\n");
        xil_printf("请修改'shake_top.v'文件, 将 'keccak_top' 的 '.Reset' 端口只连接到 '~rst_ni'，然后重新生成硬件。\r\n");
    } else {
        xil_printf("【结论】: 实验结果未能完全证实猜想，问题可能比预想的更复杂或有其他原因。\r\n");
    }
}

/*****************************************************************************/
void init_platform() { Xil_ICacheEnable(); Xil_DCacheEnable(); }
void cleanup_platform() { Xil_DCacheDisable(); Xil_ICacheDisable(); }

/*
 * main.c (最终版：功能正确性 + 性能对比)
 *
 * 包含了四个测试流程:
 * 1. 纯软件基准测试 (签名 + 验证 + 计时)
 * 2. 纯硬件加速测试 (签名 + 验证 + 计时)
 * 3. 交叉验证 1 (软件签名 -> 硬件验证)
 * 4. 交叉验证 2 (硬件签名 -> 软件验证)
 */
#include <stdio.h>
#include <string.h>
#include "xil_printf.h"
#include "xstatus.h"
#include "xtime_l.h" // <-- 引入 Zynq 的计时库

#include "api.h"
#include "fips202.h"
#include "randombytes.h"

#define MLEN 32 // 消息长度

// 函数原型
void print_hex(const char *label, const unsigned char *data, size_t len);
void init_platform();
void cleanup_platform();

int main()
{
    init_platform();
    xil_printf("\r\n--- SPHINCS+ 软/硬件全流程对比与性能基准测试 ---\r\n");

    int final_status = XST_SUCCESS;
    XTime t_start, t_end;
    u64 sw_sign_ticks, sw_verify_ticks, hw_sign_ticks, hw_verify_ticks;

    // --- 为了避免 PS 栈溢出，所有大数据都使用静态内存 ---
    static unsigned char pk[CRYPTO_PUBLICKEYBYTES];
    static unsigned char sk[CRYPTO_SECRETKEYBYTES];
    static unsigned char m[MLEN];
    static unsigned char sm[CRYPTO_BYTES + MLEN];
    static unsigned char mout[CRYPTO_BYTES + MLEN];
    unsigned long long smlen, mlen_out;

    // 生成一条固定的随机消息用于所有测试
    randombytes(m, MLEN);
    xil_printf("已生成一条 %d 字节的随机消息用于所有测试。\r\n", MLEN);

    // ===================================================================
    //  测试流程 1: 纯软件基准测试 (SW -> SW)
    // ===================================================================
    xil_printf("\r\n--- 流程 1: 纯软件签名与验证 (性能基准) ---\r\n");
    use_sw_shake_for_sphincs(); // **切换到软件**

    // 计时签名
    XTime_GetTime(&t_start);
    if (crypto_sign_keypair(pk, sk) != 0 || crypto_sign(sm, &smlen, m, MLEN, sk) != 0) {
        xil_printf("  [失败] 软件签名流程失败。\r\n");
        return XST_FAILURE;
    }
    XTime_GetTime(&t_end);
    sw_sign_ticks = t_end - t_start;
    xil_printf("  [计时] 软件签名 (包括密钥生成) 耗时: %llu 处理器时钟周期。\r\n", sw_sign_ticks);

    // 计时验证
    XTime_GetTime(&t_start);
    if (crypto_sign_open(mout, &mlen_out, sm, smlen, pk) != 0) {
        xil_printf("  [失败] 软件验证失败！\r\n");
        final_status = XST_FAILURE;
    }
    XTime_GetTime(&t_end);
    sw_verify_ticks = t_end - t_start;
    xil_printf("  [计时] 软件验证耗时: %llu 处理器时钟周期。\r\n", sw_verify_ticks);

    if (mlen_out != MLEN || memcmp(m, mout, MLEN) != 0) {
        xil_printf("  [失败] 软件验证后消息不匹配！\r\n");
        final_status = XST_FAILURE;
    } else {
        xil_printf("  [成功] 软件签名与验证流程内部一致。\r\n");
    }


    // ===================================================================
    //  测试流程 2: 纯硬件加速测试 (HW -> HW)
    // ===================================================================
    xil_printf("\r\n--- 流程 2: 纯硬件签名与验证 (性能测试) ---\r\n");
    use_hw_shake_for_sphincs(); // **切换到硬件**

    // 计时签名
    XTime_GetTime(&t_start);
    if (crypto_sign_keypair(pk, sk) != 0 || crypto_sign(sm, &smlen, m, MLEN, sk) != 0) {
        xil_printf("  [失败] 硬件签名流程失败。\r\n");
        return XST_FAILURE;
    }
    XTime_GetTime(&t_end);
    hw_sign_ticks = t_end - t_start;
    xil_printf("  [计时] 硬件签名 (包括密钥生成) 耗时: %llu 处理器时钟周期。\r\n", hw_sign_ticks);

    // 计时验证
    XTime_GetTime(&t_start);
    if (crypto_sign_open(mout, &mlen_out, sm, smlen, pk) != 0) {
        xil_printf("  [失败] 硬件验证失败！\r\n");
        final_status = XST_FAILURE;
    }
    XTime_GetTime(&t_end);
    hw_verify_ticks = t_end - t_start;
    xil_printf("  [计时] 硬件验证耗时: %llu 处理器时钟周期。\r\n", hw_verify_ticks);

    if (mlen_out != MLEN || memcmp(m, mout, MLEN) != 0) {
        xil_printf("  [失败] 硬件验证后消息不匹配！\r\n");
        final_status = XST_FAILURE;
    } else {
        xil_printf("  [成功] 硬件签名与验证流程内部一致。\r\n");
    }

    // ===================================================================
    //  交叉验证 (保持不变，作为最终的功能正确性保障)
    // ===================================================================
    xil_printf("\r\n--- 流程 3 & 4: 交叉验证以确保兼容性 ---\r\n");
    // SW -> HW
    use_sw_shake_for_sphincs();
    crypto_sign(sm, &smlen, m, MLEN, sk);
    use_hw_shake_for_sphincs();
    if (crypto_sign_open(mout, &mlen_out, sm, smlen, pk) != 0) {
        xil_printf("  [失败] 交叉验证 (软签->硬验) 失败！\r\n");
        final_status = XST_FAILURE;
    } else {
        xil_printf("  [成功] 交叉验证 (软签->硬验) 通过。\r\n");
    }
    // HW -> SW
    use_hw_shake_for_sphincs();
    crypto_sign(sm, &smlen, m, MLEN, sk);
    use_sw_shake_for_sphincs();
    if (crypto_sign_open(mout, &mlen_out, sm, smlen, pk) != 0) {
        xil_printf("  [失败] 交叉验证 (硬签->软验) 失败！\r\n");
        final_status = XST_FAILURE;
    } else {
        xil_printf("  [成功] 交叉验证 (硬签->软验) 通过。\r\n");
    }


    // ===================================================================
    //  最终性能对比报告
    // ===================================================================
    xil_printf("\r\n\n--- 最终性能对比报告 ---\r\n");
    xil_printf(" - 纯软件签名耗时: %llu 周期\r\n", sw_sign_ticks);
    xil_printf(" - 硬件加速签名耗时: %llu 周期\r\n", hw_sign_ticks);
    xil_printf(" - 纯软件验证耗时: %llu 周期\r\n", sw_verify_ticks);
    xil_printf(" - 硬件加速验证耗时: %llu 周期\r\n", hw_verify_ticks);

    // 计算并打印性能提升倍数
    if (hw_sign_ticks > 0) {
        float sign_speedup = (float)sw_sign_ticks / hw_sign_ticks;
        // 使用浮点数打印
        printf("  => 签名性能提升: %.2f 倍\r\n", sign_speedup);
    }
    if (hw_verify_ticks > 0) {
        float verify_speedup = (float)sw_verify_ticks / hw_verify_ticks;
        printf("  => 验证性能提升: %.2f 倍\r\n", verify_speedup);
    }


    if (final_status == XST_SUCCESS) {
        xil_printf("\r\n[最终结论: 全部通过] 功能正确且性能数据已采集。\r\n");
    } else {
        xil_printf("\r\n[最终结论: 存在失败] 功能验证未通过，性能数据可能无效。\r\n");
    }

    cleanup_platform();
    return final_status;
}

#include "xparameters.h"
#include "xil_cache.h"
#include "xil_printf.h"

void init_platform()
{
    /* Enable the instruction cache */
    Xil_ICacheEnable();

    /* Enable the data cache */
    Xil_DCacheEnable();

    xil_printf("Platform initialized (Caches Enabled)\r\n");
}

void cleanup_platform()
{
    /* Disable the data cache */
    Xil_DCacheDisable();

    /* Disable the instruction cache */
    Xil_ICacheDisable();

    xil_printf("Platform cleaned up (Caches Disabled)\r\n");
}

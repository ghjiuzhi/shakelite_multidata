#include <stdio.h>
#include <string.h>
#include "xil_printf.h"
#include "xil_types.h"
#include "xstatus.h"
#include "xil_cache.h"
#include "xtime_l.h"    // 用于精确计时

// 包含 SPHINCS+ 核心 API 和参数
#include "api.h"
#include "params.h"

// 定义要签名的消息长度
#define MESSAGE_LEN 32

/************************** 函数声明 ***************************/
void print_hex(const char *label, const unsigned char *data, size_t len);
int run_sphincs_test();
void init_platform();
void cleanup_platform();

/*****************************************************************************/
/**
* @brief    程序主入口.
******************************************************************************/
int main()
{
    int status;
    init_platform();

    xil_printf("\r\n\n--- SPHINCS+ Hardware Accelerated Test ---\r\n");
    // 打印当前使用的参数集
    xil_printf("SPHINCS+ Parameter Set: %s\r\n", xstr(PARAMS));
    // 打印计时器的时钟频率，用于验证计时准确性
    xil_printf("Timer clock frequency: %lu Hz\r\n\n", COUNTS_PER_SECOND);

    status = run_sphincs_test();

    if (status == XST_SUCCESS) {
        xil_printf("\r\n[SUCCESS] SPHINCS+ signature and verification flow completed successfully!\r\n");
    } else {
        xil_printf("\r\n[FAILURE] SPHINCS+ signature and verification flow failed.\r\n");
    }

    cleanup_platform();
    return status;
}

/*****************************************************************************/
/**
* @brief    执行完整的SPHINCS+密钥生成、签名和验证流程.
******************************************************************************/
int run_sphincs_test()
{
    // 使用 static 将大的数组分配在全局数据区，防止栈溢出
    static unsigned char pk[CRYPTO_PUBLICKEYBYTES];
    static unsigned char sk[CRYPTO_SECRETKEYBYTES];
    static unsigned char m[MESSAGE_LEN];
    static unsigned char sm[CRYPTO_BYTES + MESSAGE_LEN];
    static unsigned char mout[CRYPTO_BYTES + MESSAGE_LEN];

    unsigned long long smlen;
    unsigned long long mlen_out;
    int ret_val;

    // 用于计时的变量
    XTime t_start, t_end;
    float time_us;

    // --- 步骤 1: 准备一个32字节的示例消息 ---
    xil_printf("--- Step 1: Preparing a %d-byte message ---\r\n", MESSAGE_LEN);
    for (int i = 0; i < MESSAGE_LEN; i++) {
        m[i] = (unsigned char)i;
    }
    print_hex("  Original Message", m, MESSAGE_LEN);

    // --- 步骤 2: 生成密钥对 ---
    xil_printf("\r\n--- Step 2: Generating keypair (%d public bytes, %d secret bytes) ---\r\n", CRYPTO_PUBLICKEYBYTES, CRYPTO_SECRETKEYBYTES);
    XTime_GetTime(&t_start);
    if (crypto_sign_keypair(pk, sk) != 0) {
        xil_printf("  [ERROR] Keypair generation failed!\r\n");
        return XST_FAILURE;
    }
    XTime_GetTime(&t_end);
    time_us = 1.0 * (t_end - t_start) / (COUNTS_PER_SECOND / 1000000);
    xil_printf("  Keypair generated successfully in %.2f us.\r\n", time_us);
    print_hex("  Public Key (first 32 of %d bytes)", pk, 32);

    // --- 步骤 3: 对消息进行签名 ---
    xil_printf("\r\n--- Step 3: Signing the message ---\r\n");
    XTime_GetTime(&t_start);
    if (crypto_sign(sm, &smlen, m, MESSAGE_LEN, sk) != 0) {
        xil_printf("  [ERROR] Signing function failed!\r\n");
        return XST_FAILURE;
    }
    XTime_GetTime(&t_end);
    time_us = 1.0 * (t_end - t_start) / (COUNTS_PER_SECOND / 1000000);

    xil_printf("  Message signed in %.2f us.\r\n", time_us);
    xil_printf("  Reported signed message length: %llu bytes.\r\n", smlen);

    // !! 关键检查 !! 验证签名长度是否符合预期
    if (smlen != (CRYPTO_BYTES + MESSAGE_LEN)) {
        xil_printf("  [CRITICAL FAILURE] Signature length is INCORRECT!\r\n");
        xil_printf("    Expected length: %d bytes\r\n", CRYPTO_BYTES + MESSAGE_LEN);
        xil_printf("    Actual length:   %llu bytes\r\n", smlen);
        xil_printf("    This indicates the hardware accelerator produced an incorrect hash. Halting.\r\n");
        return XST_FAILURE;
    }
    xil_printf("  Signature length is correct.\r\n");
    print_hex("  Signature part (first 32 of %d bytes)", sm, 32);


    // --- 步骤 4: 使用公钥验证签名 ---
    xil_printf("\r\n--- Step 4: Verifying the signature ---\r\n");
    XTime_GetTime(&t_start);
    ret_val = crypto_sign_open(mout, &mlen_out, sm, smlen, pk);
    XTime_GetTime(&t_end);

    if (ret_val != 0) {
        xil_printf("  [ERROR] Verification function returned non-zero code: %d! Signature is invalid.\r\n", ret_val);
        return XST_FAILURE;
    }
    time_us = 1.0 * (t_end - t_start) / (COUNTS_PER_SECOND / 1000000);
    xil_printf("  Signature verified successfully in %.2f us.\r\n", time_us);
    xil_printf("  Recovered message length: %llu bytes.\r\n", mlen_out);
    print_hex("  Recovered Message", mout, mlen_out);

    // --- 步骤 5: 最终一致性检查 ---
    xil_printf("\r\n--- Step 5: Final Check ---\r\n");
    if (mlen_out != MESSAGE_LEN) {
        xil_printf("  [ERROR] Message length mismatch! Original: %d, Recovered: %llu\r\n", MESSAGE_LEN, mlen_out);
        return XST_FAILURE;
    }
    if (memcmp(m, mout, MESSAGE_LEN) != 0) {
        xil_printf("  [ERROR] Message content mismatch!\r\n");
        return XST_FAILURE;
    }
    xil_printf("  Original and recovered messages match perfectly.\r\n");

    return XST_SUCCESS;
}

/**
 * @brief 辅助函数：以十六进制格式打印字节数组
 */
void print_hex(const char *label, const unsigned char *data, size_t len)
{
    xil_printf("%s: ", label);
    for (size_t i = 0; i < len; i++) {
        xil_printf("%02x", data[i]);
    }
    xil_printf("\r\n");
}

/**
 * @brief 初始化平台，主要是开启缓存
 */
void init_platform()
{
    Xil_DCacheDisable();
    Xil_ICacheEnable();
    Xil_DCacheEnable();
}

/**
 * @brief 清理平台，主要是关闭缓存
 */
void cleanup_platform()
{
    Xil_DCacheDisable();
    Xil_ICacheDisable();
}

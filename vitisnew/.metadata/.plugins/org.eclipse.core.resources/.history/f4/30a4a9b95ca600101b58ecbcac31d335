/***************************** Include Files *******************************/

#include "xparameters.h"
#include "xil_printf.h"
#include "xstatus.h"
#include "xil_cache.h"
#include "xil_io.h"
#include "sha3_1003_tIP1.h" // IP核的驱动头文件

/************************** Constant Definitions ***************************/

#define IP_CORE_BASEADDR XPAR_SHA3_1003_TIP1_0_S0_AXI_BASEADDR

// 根据Verilog文件定义寄存器地址偏移
#define REG_CONTROL_OFFSET      0x00 // slv_reg0: mode, start, hold
#define REG_DIN_LOW_OFFSET      0x04 // slv_reg1: 数据输入低32位
#define REG_DIN_HIGH_OFFSET     0x08 // slv_reg2: 数据输入高32位
#define REG_CONTROL2_OFFSET     0x0C // slv_reg3: last_din, din_valid, etc.
#define REG_STATUS_OFFSET       0x10 // slv_reg4: 状态寄存器 (busy, done)
#define REG_RESULT_START_OFFSET 0x14 // 结果寄存器的起始地址

// 根据Verilog文件定义控制位
#define CONTROL_START_BIT       (1 << 3) // slv_reg0[3] 是 start_i
#define CONTROL2_LAST_DIN_BIT   (1 << 0) // slv_reg3[0] 是 last_din_i
#define CONTROL2_DIN_VALID_BIT  (1 << 5) // slv_reg3[5] 是 din_valid_i
#define CONTROL2_DOUT_READY_BIT (1 << 6) // slv_reg3[6] 是 dout_ready_i
#define STATUS_DOUT_VALID_BIT   (1 << 3) // slv_reg4[3] 是 dout_full_valid_o

#define RESULT_REG_COUNT 42 // 共有42个32位结果寄存器

// 模式定义(shake_top中）
// SHAKE128模式
//localparam  MODE_SHAKE128 = 3'b000;
// SHAKE256模式
//localparam  MODE_SHAKE256 = 3'b001;
// SHA3-256模式
//localparam  MODE_SHA3_256 = 3'b010;
// SHA3-512模式
//localparam  MODE_SHA3_512 = 3'b011;
// SHA3-224模式
//localparam  MODE_SHA3_224 = 3'b100;
// SHA3-384模式
//localparam  MODE_SHA3_384 = 3'b101;

/************************** Function Prototypes ****************************/
void init_platform();
void cleanup_platform();
int test_sha3_hash_and_read_result(u32 base_addr);
int test_sha3_and_read_result(u32 base_addr);
int test_sha3_256_abc(u32 base_addr);

/*****************************************************************************/
/**
* @brief 主函数
******************************************************************************/
int main()
{
    int status;
    init_platform();

    xil_printf("\r\n--- SHA3_1003_TIP1 IP Core - 哈希计算与结果读取测试 ---\r\n");

    status = test_sha3_256_abc(IP_CORE_BASEADDR);

    if (status == XST_SUCCESS) {
        xil_printf("\r\n[成功] 哈希计算和结果读取测试完成!\r\n");
    } else {
        xil_printf("\r\n[失败] 测试过程中发生错误!\r\n");
    }

    cleanup_platform();
    return status;
}

/*****************************************************************************/
/**
* @brief   执行完整的SHA3哈希流程：写入数据，启动，轮询，读取结果。(这个测的其实是shake128）
*
* @param   base_addr 是IP核的基地址。
*
* @return  - XST_SUCCESS: 成功 / - XST_FAILURE: 失败
******************************************************************************/
int test_sha3_hash_and_read_result(u32 base_addr)
{
    u64 write_data = 0x00636261000000;
    u32 low_32 = (u32)write_data;
    u32 high_32 = (u32)(write_data >> 32);
    u32 status_reg;
    u32 result_buffer[RESULT_REG_COUNT];
    int i;
    int timeout = 1000000; // 设置一个超时计数器防止死循环

    // --- 步骤 1: 写入64位输入数据 ---
    xil_printf("\r\n步骤 1: 写入输入数据 0x%016llX\r\n", write_data);
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_DIN_LOW_OFFSET, low_32);
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_DIN_HIGH_OFFSET, high_32);
    xil_printf("  - 数据已写入 slv_reg1 和 slv_reg2\r\n");

    // --- 步骤 2: 设置数据有效并准备接收输出 ---
    // 根据Verilog, 我们需要置位 din_valid, last_din, 和 dout_ready
    // din_valid告诉IP核数据准备好了，last_din表示这是最后一块数据
    // dout_ready表示PS端已经准备好接收结果
    // 注意：我们在这里先不设置 din_valid，因为要将它和 start 一起作为脉冲发送
       u32 control2_val = CONTROL2_LAST_DIN_BIT | CONTROL2_DOUT_READY_BIT;
       SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL2_OFFSET, control2_val);
       xil_printf("步骤 2: 设置 slv_reg3 (值为 0x%08X), 准备发送数据有效信号\r\n", control2_val);

       // --- 步骤 3: 启动哈希计算并发送数据有效脉冲 ---
       // 通过在slv_reg0中写入start位来触发计算。
       // 同时，在slv_reg3中置位din_valid位，告诉IP核数据有效。
       xil_printf("步骤 3: 启动哈希计算并发送数据有效脉冲\r\n");

       // **【关键修改】**
       // 将 start 和 din_valid 一起置位
       SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL_OFFSET, CONTROL_START_BIT);
       SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL2_OFFSET, control2_val | CONTROL2_DIN_VALID_BIT);

       // 在下一个写操作中，将它们同时清零，形成脉冲
       SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL_OFFSET, 0);
       SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL2_OFFSET, control2_val); // 恢复slv_reg3，清除din_valid位

       xil_printf("  - 启动和数据有效信号已发送\r\n");

       // --- 步骤 4: 轮询状态寄存器等待计算完成 ---
       xil_printf("步骤 4: 等待计算完成...\r\n");

       // **【最终修改】**
       // 定义 result_ready 位，它在 slv_reg4 的第5位
       #define STATUS_RESULT_READY_BIT (1 << 5)

       do {
           status_reg = SHA3_1003_TIP1_mReadReg(base_addr, REG_STATUS_OFFSET);
           timeout--;
       } while (((status_reg & STATUS_RESULT_READY_BIT) == 0) && (timeout > 0)); // 修改为等待 bit 5

       if (timeout <= 0) {
           xil_printf("  - [错误] 等待计算完成超时！状态寄存器(slv_reg4)值为: 0x%08X\r\n", status_reg);
           return XST_FAILURE;
       }
       xil_printf("  - 计算完成! 状态寄存器(slv_reg4)值为: 0x%08X\r\n", status_reg);

       // 计算完成后，最好向一个控制寄存器写一个“清除”信号，以便下次计算
       // 如果您的硬件没有这个逻辑，可以省略这一步。
       // 例如：SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL_OFFSET, CLEAR_RESULT_READY_BIT);

    // --- 步骤 5: 从结果寄存器区读取哈希值 ---
    xil_printf("步骤 5: 读取1344位的哈希结果 (从地址 0x%08X 开始)\r\n", base_addr + REG_RESULT_START_OFFSET);
    for (i = 0; i < RESULT_REG_COUNT; i++) {
        result_buffer[i] = SHA3_1003_TIP1_mReadReg(base_addr, REG_RESULT_START_OFFSET + i * 4);
    }

    // --- 步骤 6: 打印哈希结果 ---
    xil_printf("  --- 哈希结果 ---\r\n");
    for (i = 0; i < RESULT_REG_COUNT; i++) {
        xil_printf("    reg[%2d] (addr offset 0x%02X): 0x%08X\r\n", i, REG_RESULT_START_OFFSET + i*4, result_buffer[i]);
    }

    return XST_SUCCESS;
}

/*****************************************************************************/
/**
* @brief   测试 SHA3-256，输入为 "abc"，并读取全部1344位硬件输出。更改mode为1则选的是shake256
*
* @param   base_addr 是IP核的基地址。
*
* @return  - XST_SUCCESS: 成功 / - XST_FAILURE: 失败
******************************************************************************/
int test_sha3_256_abc(u32 base_addr)
{
    // --- 步骤 1: 准备输入数据 "abc" ---
//    u32 high_32 = 0x00636261;
//    u32 low_32 = 0x00000000;
//    u32 high_32 = 0x00323246;
//    u32 low_32 = 0x00626261;
    u64 write_data = 0x11223344AABBCCDD;
    u32 low_32 = (u32)write_data;
    u32 high_32 = (u32)(write_data >> 32);
    u32 status_reg;
    u32 result_buffer[RESULT_REG_COUNT];
    int i;
    int timeout = 1000000;

    xil_printf("\r\n--- SHAKE-256 最终调试, 输入: \"abc\", 读取完整1344位输出 ---\r\n");
    xil_printf("\r\n--- 这是一次全新的测试，如果看到这句话，代码就更新成功了 ---\r\n");
    xil_printf("步骤 1: 准备写入的数据 (高32位: 0x%08X, 低32位: 0x%08X)\r\n", high_32, low_32);
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_DIN_LOW_OFFSET, low_32);
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_DIN_HIGH_OFFSET, high_32);

    // --- 步骤 2: 设置控制信号 ---
    // 根据SHA3标准，填充规则是在消息后附加 '01' 位。
    // 我们的输入是 "abc" (3字节 = 24位)，即 0x616263。
    // 附加 '01' 后变成 26 位: 01100001 01100010 01100011 '01'
    // 这在字节层面很难精确控制。让我们回到最初的正确设置，
    // 即明确告诉硬件有效字节数是3。如果这仍然失败，则100%是硬件问题。
    u32 control2_val = CONTROL2_LAST_DIN_BIT | (3 << 1) | CONTROL2_DOUT_READY_BIT;
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL2_OFFSET, control2_val);
    xil_printf("步骤 2: 设置 slv_reg3 (值为 0x%08X), 重新指定有效字节数为3\r\n", control2_val);

    // --- 步骤 3: 设置模式为SHA3-256 (模式3) 并启动 ---
    u32 control_val = 1;
    xil_printf("步骤 3: 设置模式为 Shake-256 (slv_reg0=1) 并启动\r\n");
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL_OFFSET, control_val | CONTROL_START_BIT);
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL2_OFFSET, control2_val | CONTROL2_DIN_VALID_BIT);
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL_OFFSET, control_val);
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL2_OFFSET, control2_val);

    // --- 步骤 4: 等待完成 ---
    xil_printf("步骤 4: 等待计算完成...\r\n");
    do {
        status_reg = SHA3_1003_TIP1_mReadReg(base_addr, REG_STATUS_OFFSET);
        timeout--;
    } while (((status_reg & STATUS_RESULT_READY_BIT) == 0) && (timeout > 0));

    if (timeout <= 0) {
        xil_printf("  - [错误] 等待超时! 状态寄存器: 0x%08X\r\n", status_reg);
        return XST_FAILURE;
    }
    xil_printf("  - 计算完成! 状态寄存器: 0x%08X\r\n", status_reg);

    // --- 步骤 5 & 6: 读取并打印全部1344位结果 ---
    xil_printf("步骤 5: 读取全部1344位的哈希结果\r\n");
    xil_printf("  --- 哈希结果 ---\r\n");
    for (i = 0; i < RESULT_REG_COUNT; i++) {
        result_buffer[i] = SHA3_1003_TIP1_mReadReg(base_addr, REG_RESULT_START_OFFSET + i * 4);
        xil_printf("    reg[%2d]: 0x%08X\r\n", i, result_buffer[i]);
    }

    return XST_SUCCESS;
}
/*****************************************************************************/
/**
* @brief   执行完整的SHA3-256哈希流程，输入为"abc"。
*
* @param   base_addr 是IP核的基地址。
*
* @return  - XST_SUCCESS: 成功 / - XST_FAILURE: 失败
******************************************************************************/
int test_sha3_and_read_result(u32 base_addr)
{
    // --- 步骤 1: 准备输入数据 "abc" ---

    // "abc" 对应的ASCII码是 0x61, 0x62, 0x63。
    // 我们需要将这3个字节的数据放入64位的输入寄存器中。
    // 硬件的输入 din_i = {slv_reg2, slv_reg1}
    // 我们希望硬件看到的字节流是 61 62 63 00 00 00 00 00
    // 这意味着 slv_reg2 需要接收到 "61 62 63 00"
    // slv_reg1 需要接收到 "00 00 00 00"
    //
    // 由于ARM处理器是小端序(Little-Endian)，它会反转字节顺序。
    // 所以，为了让硬件看到 "61 62 63 00"，我们需要在C代码中写入 0x00636261。
    u32 high_32 = 0x00636261; // 包含 "abc" 的高32位
    u32 low_32 = 0x00000000;  // 低32位全为0

    u32 status_reg;
    u32 result_buffer[RESULT_REG_COUNT]; // 假设输出长度不变
    int i;
    int timeout = 1000000;

    xil_printf("\r\n--- SHA3-256 测试, 输入: \"abc\" ---\r\n");
    xil_printf("步骤 1: 准备写入的数据\r\n");
    xil_printf("  - 高32位 (Hex): 0x%08X\r\n", high_32);
    xil_printf("  - 低32位 (Hex): 0x%08X\r\n", low_32);

    // 写入数据寄存器
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_DIN_LOW_OFFSET, low_32);
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_DIN_HIGH_OFFSET, high_32);
    xil_printf("  - 数据已写入 slv_reg1 和 slv_reg2\r\n");

    // --- 步骤 2: 设置控制信号 ---

    // last_din (bit 0): 1, 因为这是最后一块数据。
    // last_din_byte (bits 4:1): 3, 因为"abc"是3个字节。所以要写入 (3 << 1)。
    // dout_ready (bit 6): 1, 表示PS端准备好接收结果。
    u32 control2_val = CONTROL2_LAST_DIN_BIT | (3 << 1) | CONTROL2_DOUT_READY_BIT;
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL2_OFFSET, control2_val);
    xil_printf("步骤 2: 设置 slv_reg3 (值为 0x%08X), 指定有效字节数为3\r\n", control2_val);


    // --- 步骤 3: 设置模式并启动计算 ---

    // 根据 keccak_top.v, SHA3-256 对应的 mode_i 是 3'b011 (十进制 3)。
    u32 control_val = 3; // 设置模式为 SHA3-256

    xil_printf("步骤 3: 设置模式为 SHA3-256 (slv_reg0=3) 并启动计算\r\n");

    // 将 start 和 din_valid 一起置位
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL_OFFSET, control_val | CONTROL_START_BIT);
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL2_OFFSET, control2_val | CONTROL2_DIN_VALID_BIT);

    // 形成脉冲
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL_OFFSET, control_val); // 清除start位，但保持mode位
    SHA3_1003_TIP1_mWriteReg(base_addr, REG_CONTROL2_OFFSET, control2_val); // 清除din_valid位

    xil_printf("  - 启动和数据有效信号已发送\r\n");

    // --- 步骤 4: 轮询状态寄存器等待计算完成 ---
    xil_printf("步骤 4: 等待计算完成...\r\n");
    #define STATUS_RESULT_READY_BIT (1 << 5)
    do {
        status_reg = SHA3_1003_TIP1_mReadReg(base_addr, REG_STATUS_OFFSET);
        timeout--;
    } while (((status_reg & STATUS_RESULT_READY_BIT) == 0) && (timeout > 0));

    if (timeout <= 0) {
        xil_printf("  - [错误] 等待计算完成超时！状态寄存器(slv_reg4)值为: 0x%08X\r\n", status_reg);
        return XST_FAILURE;
    }
    xil_printf("  - 计算完成! 状态寄存器(slv_reg4)值为: 0x%08X\r\n", status_reg);


    // --- 步骤 5: 读取哈希结果 ---
    // SHA3-256 的输出是256位（32字节），也就是8个32位寄存器。
    #define SHA3_256_RESULT_REGS 8
    xil_printf("步骤 5: 读取256位的哈希结果 (前 %d 个寄存器)\r\n", SHA3_256_RESULT_REGS);
    for (i = 0; i < SHA3_256_RESULT_REGS; i++) {
        result_buffer[i] = SHA3_1003_TIP1_mReadReg(base_addr, REG_RESULT_START_OFFSET + i * 4);
    }

    // --- 步骤 6: 打印哈希结果 ---
    xil_printf("  --- 哈希结果 ---\r\n");
    for (i = 0; i < SHA3_256_RESULT_REGS; i++) {
        xil_printf("    reg[%2d] (addr offset 0x%02X): 0x%08X\r\n", i, REG_RESULT_START_OFFSET + i*4, result_buffer[i]);
    }

    return XST_SUCCESS;
}

/*****************************************************************************/
/**
* @brief   平台初始化
******************************************************************************/
void init_platform()
{
    Xil_ICacheEnable();
    Xil_DCacheEnable();
}


/*****************************************************************************/
/**
* @brief   平台清理
******************************************************************************/
void cleanup_platform()
{
    Xil_DCacheDisable();
    Xil_ICacheDisable();
}

#include "fpga_sha_driver.h"
#include "xparameters.h"
#include "xil_io.h"
#include <string.h>      // For memcpy
#include "xil_printf.h"  // For debugging prints

// Constant definitions from your successful test code
#define IP_CORE_BASEADDR        XPAR_SHA3_1003_TIP1_0_S0_AXI_BASEADDR

// Register address offsets
#define REG_CONTROL_OFFSET      0x00
#define REG_DIN_LOW_OFFSET      0x04
#define REG_DIN_HIGH_OFFSET     0x08
#define REG_CONTROL2_OFFSET     0x0C
#define REG_STATUS_OFFSET       0x10
#define REG_RESULT_START_OFFSET 0x14

// Control bit definitions
#define CONTROL_START_BIT       (1 << 3)
#define CONTROL2_LAST_DIN_BIT   (1 << 0)
#define CONTROL2_DIN_VALID_BIT  (1 << 5)
#define CONTROL2_DOUT_READY_BIT (1 << 6)
#define STATUS_RESULT_READY_BIT (1 << 5)

// The total number of 32-bit registers holding the result state
#define RESULT_REG_COUNT 42

/**
 * @brief Core function to drive the SHAKE256 hardware IP with debug prints.
 */
void shake256_hw(uint8_t *out, size_t outlen, const uint8_t *in, const size_t inlen)
{
    u32 base_addr = IP_CORE_BASEADDR;
    size_t remaining_len = inlen;
    const uint8_t *data_ptr = in;
    int timeout;
    int chunk_count = 0;

    xil_printf("----- HW DRIVER: shake256_hw called -----\r\n");
    xil_printf("  inlen: %u, outlen: %u\r\n", (u32)inlen, (u32)outlen);

    // --- Step 1: Set Mode and dout_ready ---
    u32 control_val = 1; // Mode 1: Shake-256
    Xil_Out32(base_addr + REG_CONTROL_OFFSET, control_val);
    xil_printf("  HW: Set Mode=1 (Shake256)\r\n");

    u32 control2_base = CONTROL2_DOUT_READY_BIT;
    Xil_Out32(base_addr + REG_CONTROL2_OFFSET, control2_base);

    // --- Step 2: Pulse Start to initialize the IP state machine ---
    Xil_Out32(base_addr + REG_CONTROL_OFFSET, control_val | CONTROL_START_BIT);
    Xil_Out32(base_addr + REG_CONTROL_OFFSET, control_val);
    xil_printf("  HW: Pulsed START bit\r\n");

    // --- Step 3: Stream input data in 8-byte (64-bit) chunks ---
    while (remaining_len > 8) {
        u64 chunk;
        memcpy(&chunk, data_ptr, 8);

        xil_printf("  HW: Sending chunk %d, data = 0x%016llx\r\n", chunk_count, chunk);
        Xil_Out32(base_addr + REG_DIN_LOW_OFFSET, (u32)(chunk & 0xFFFFFFFF));
        Xil_Out32(base_addr + REG_DIN_HIGH_OFFSET, (u32)(chunk >> 32));

        xil_printf("  HW: Pulsing din_valid for chunk %d (control2 = 0x%08x)\r\n", chunk_count, (unsigned int)(control2_base | CONTROL2_DIN_VALID_BIT));
        Xil_Out32(base_addr + REG_CONTROL2_OFFSET, control2_base | CONTROL2_DIN_VALID_BIT);
        Xil_Out32(base_addr + REG_CONTROL2_OFFSET, control2_base);

        data_ptr += 8;
        remaining_len -= 8;
        chunk_count++;
    }

    // --- Step 4: Send the final data chunk (1 to 8 bytes) ---
    u64 last_chunk = 0;
    if (remaining_len > 0) {
        memcpy(&last_chunk, data_ptr, remaining_len);
    }
    xil_printf("  HW: Sending LAST chunk %d, data = 0x%016llx, len = %u bytes\r\n", chunk_count, last_chunk, (unsigned int)remaining_len);

    Xil_Out32(base_addr + REG_DIN_LOW_OFFSET, (u32)(last_chunk & 0xFFFFFFFF));
    Xil_Out32(base_addr + REG_DIN_HIGH_OFFSET, (u32)(last_chunk >> 32));

    u32 control2_final = control2_base | CONTROL2_LAST_DIN_BIT | ((u32)remaining_len << 1);
    Xil_Out32(base_addr + REG_CONTROL2_OFFSET, control2_final);

    xil_printf("  HW: Pulsing din_valid for LAST chunk %d (control2 = 0x%08x)\r\n", chunk_count, (unsigned int)(control2_final | CONTROL2_DIN_VALID_BIT));
    Xil_Out32(base_addr + REG_CONTROL2_OFFSET, control2_final | CONTROL2_DIN_VALID_BIT);
    Xil_Out32(base_addr + REG_CONTROL2_OFFSET, control2_final);

    // --- Step 5: Wait for the result ---
    xil_printf("  HW: Waiting for result_ready bit...\r\n");
    timeout = 1000000;
    while (((Xil_In32(base_addr + REG_STATUS_OFFSET) & STATUS_RESULT_READY_BIT) == 0) && (timeout > 0)) {
        timeout--;
    }

    if (timeout <= 0) {
        xil_printf("  [HW DRIVER ERROR] Timeout waiting for IP core!\r\n");
        return; // Exit on error
    }
    xil_printf("  HW: Result is ready!\r\n");

    // --- Step 6: Read the output data ---
    u32 result_buffer[RESULT_REG_COUNT];
    for (int i = 0; i < RESULT_REG_COUNT; i++) {
        result_buffer[i] = Xil_In32(base_addr + REG_RESULT_START_OFFSET + i * 4);
    }

    size_t copy_len = (outlen > sizeof(result_buffer)) ? sizeof(result_buffer) : outlen;
    memcpy(out, result_buffer, copy_len);
    xil_printf("  HW: Read %u bytes of result.\r\n", (unsigned int)copy_len);
    xil_printf("----- HW DRIVER: Finished -----\r\n\n");
}
